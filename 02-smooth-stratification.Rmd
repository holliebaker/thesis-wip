# Smooth Stratification {#sec:smooth-strat}

Before turning our attention to cylindrical decompositions, we will present another useful algorithm for decomposing a semialgebraic set.
A smooth stratification is a finite partition of a set into smooth manifolds.
This algorithm will form part of the later work in constructing a CAD with monotone cells, which requires the input sets to first be partitioned into smooth smooth manifolds (see Section \@ref(sec:quasi-affine). However, the algorithm and implementation described in this section are useful in their own right.

In 1957, @whitney1992 proved that every algebraic variety can be partitioned into a finite set of smooth manifolds, each of which is a semialgebraic set.
Lojasiewicz extended this result by proving that every real semianalytic set admits a smooth stratification, such that every stratum is a semianalytic set [@lojasiewicz1964]. However, the proof was non-constructive and did not provide any information on the class of functions defining the strata.
As part of his Complement Theorem, @gabrielov1996 proved that the strata of a semianalytic set can be defined by functions belonging to the smallest extensions of a family of functions defining the set which is closed under addition, multiplication and taking partial derivatives. One such class of functions is the Pfaffian functions.
@gv1995 present an algorithm for computing a smooth stratification of a semi-pfaffian set, along with an estimate of its complexity and bounds on the formats of the strata it produces. This algorithm (also summarised in @gv04, Section 6) will be presented.

::: {.definition}
[@gv04, Definition 6.2]
A weak stratification of a semi-Pfaffian set $X \subset \R^n$ is a partition of $X$ into a finite number of non-singular manifolds $X_k, 0 \le k \le n$ called strata. Strata need not be connected (or even have a finite number of connected components) and may be empty.

The stratification is called basic if all strata are basic semi-Pfaffian sets which are effectively nonsingular.
I.e., the system of equations and inequalities defining each stratum $X_k$ of codimension $k$ includes a set of $k$ Pfaffian functions
$$
h_{i_1}, \ldots , h_{i_k}
$$ such that the restriction $h_{i_j}\vert_{X_i} = 0$ and $d h_{i_j} \ne 0$ at every point $\mathbf{x} \in X_k$, for each $1 \le j \le k$.
:::

Note that this definition does not guarantee any other desirable properties of the manifolds $X_k$. E.g., the closure of a stratum may not be a union of strata.

## Description of the algorithm { #sec:strat-alg-description }

Since every semialgebraic set is a semi-Pfaffian set, this algorithm can be applied to the semialgebraic sets with almost no modifications.
Since each stratum is defined by sign conditions on partial derivatives of input functions, it is clear that if the input set is semialgebraic, then each stratum will be semialgebraic, too.  Furthermore, as emptiness of semialgebraic sets can be decided, e.g., using the cylindrical algebraic decomposition algorithm, an Oracle will not be needed in this variation of the algorithm.
The algorithm relies on computing partial derivatives of the functions defining the input set. In the semi-Pfaffian case, the number of partial derivatives which must be considered is bounded by the format of the input set. As every polynomial has  a finite number of partial derivatives, the bound for the semialgebraic case will simply be the degree of the polynomial.

We will need the following notation for partial derivatives and the partial differential operator defined by @gv1995.

::: {.definition #pdo }
[@gv1995, Definition 2]
Let $f \in \Z[x_1,\ldots,x_n]$ be a polynomial and let $(m_1,\ldots,m_n) \subset \Z_{\ge 0}^n$ be a multi-index associated to one of its partial derivatives.
I.e., we write
$$
\partial f^{(m_1,\ldots,m_n)} =
\dfrac{\partial^{m_1} f}{\partial x_1} \cdots \dfrac{\partial^{m_n} f}{\partial x_n}.
$$
:::

::: {.definition}
[@gv1995, Definition 2]
We define the partial differential operator $\partial_{\mathbf{h}, \mathbf{i}, j} f$ (where the argument $f$ is a polynomial) as the determinant
$$
\det\begin{pmatrix}\dfrac{\partial h_{1}}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial h_{1}}{\partial x_{i_{k}}} & \dfrac{\partial h_{1}}{\partial x_{j}}\\
 & \vdots\\
\dfrac{\partial h_{k}}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial h_{k}}{\partial x_{i_{k}}} & \dfrac{\partial h_{k}}{\partial x_{j}}\\
\dfrac{\partial f}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial f}{\partial x_{i_{k}}} & \dfrac{\partial f}{\partial x_{j}}
\end{pmatrix}.
$$
We write $\partial^m_{\mathbf{h}, \mathbf{i}, j}$ to mean the $m$-th iteration of $\partial_{\mathbf{h}, \mathbf{i}, j}$.
:::

We can now present the algorithm from @gv1995, Theorem 2.

::: {.theorem #strat }
Let
$$
X := \{ \mathbf{x} \in \R^n \mid f_1 = 0, \ldots, f_k = 0, g_1 > 0, \ldots, g_\ell > 0 \},
$$
be a semialgebraic set defined by $s = k + \ell$ different polynomials of maximum degree $d$.
Then there is an algorithm, without oracle, which partitions $X$ into a family
$$
{\cal X} = (X_0, \ldots, X_n)
$$
such that, if $X$ is nonsingular, $X_0 = X$ and all other sets are empty.
Otherwise, $X_0 = \emptyset$ and each $X_k, 1 \le k \le n$ is a possibly empty, effectively nonsingular stratum of codimension $k$.
This algorithm has complexity
$$
3^{s}\left(s(d+1)\right)^{O(n)^{2}}.
$$
The number of strata does not exceed $s^{n} (d + 1)^2$, and each stratum is defined by at most $s (d + 1)^2$ polynomial equations and inequalities of maximum degree $(d + 1)^2$.
:::


Let $$
X = \{ \mathbf{x} \in \R^n \mid f_1(\mathbf{x}) = 0,\ldots,f_s(\mathbf{x}) = 0, g_1(\mathbf{x}) > 0, \ldots, g_t(\mathbf{x}) > 0 \}.
$$

::: {.algorithm data-latex="Smooth Stratification"}
$${\cal X} := \rm{Stratify}(k, F, \mathbf{h}, \mathbf{i}, G)$$

**Input:**

  - $0 \le k \le n$,
  - $F = (f_1,\ldots,f_s) \in \Z[x_1,\ldots,z_n]$ is a list of polynomials,
  - $\mathbf{h} = (h_k, \ldots,h_1, h_0) \in \Z[x_1,\ldots,x_n]$ such that $h_0 = 0$,
  - $\mathbf{i} = (i_k, \ldots, i_1,i_0) \in \Z_{\ge 0}$ such that $i_0 = 0$,
  - $G = \{g_1,\ldots,g_t\} \subset \Z[x_1,\ldots,x_n]$.

**Output:**
$$
{\cal X} = (X_{k+1}, \ldots, X_n)
$$
$X_i, k+1 \le i \le n$ is a possibly empty, effectively nonsingular stratum of codimension $i$.
Note that ${\cal X}_{n+1} = ()$.

Proceed by induction on $i_k$.

- Base case: $i_k = n$.

  - Return ${\cal X}_{x+1} = (\emptyset, \ldots, \emptyset)$.

- Otherwise

  - Initialise

    - $X' := X = \{ f_1 = 0,\ldots,f_s = 0, g_1 > 0, \ldots, g_t > 0 \}$,

    - ${\cal F} := \{ ((0,\ldots,0,1), f_1), \ldots, ((0,\ldots,0,s), f_s) \}$
      (the set of input polynomials equipped with initial indices),

    - $X_{k+1} = \emptyset$ be the initial set of strata of codimension $k+1$.

  - For indices $\mathbf{i},\mathbf{j} \in \Z_{\ge 0}^n$,
    - let $\mathbf{i} \prec \mathbf{j}$ mean that $\mathbf{i}$ is lexicographically less than $\mathbf{j}$
    - and $\mathbf{i} \preceq \mathbf{j}$ denote $\mathbf{i}\prec \mathbf{j}$ or $\mathbf{i} = \mathbf{j}$.

  - We will iterate over each index $\mathbf{m} = (i_n,\ldots,i_{k+1},j) \in \Z_{\ge 0}^{n-k+1}$ in ascending lexicographical order, beginning with $(0,\ldots,0,1)$.

  - Partial derivatives $\partial^{(0,\ldots,0,i_{k+1},\ldots,i_n)}$ of functions $f$ in ${\cal F}$ will be computed.

  - For each $f\in {\cal F}$, maximal index $$M := (\deg_n(f), \ldots, \deg_{k+1}(f)).$$

  - Each index $(i_n,\ldots,i_{k+1},j)$ has the property that
  $$
  (0,\ldots,1) \preceq (i_n,\ldots,i_{k+1}) \preceq M_j.
  $$

    - Let $\mathbf{m} = (0,\ldots,0,i_\ell,\ldots,i_{k+1},j)$ be one of these indices and define
    $$
    \mathbf{j} = (0, \ldots, 0, i_{\ell} - 1, i_{\ell - 1}, \ldots, i_{k+1},j).
    $$

    - Let
    $$
    s_{k+1} := \partial_{(h_{1,},\ldots,,h_{k}),(i_{1},\ldots,i_{k}),\ell}^{i_{\ell}}\ldots\partial_{(h_{1,},\ldots,,h_{k}),(i_{1},\ldots,i_{k}),i_{k}+1}^{i_{i}+1}f_{j}
    $$
    where $f_j$ is the polynomial in $\cal F$ with index $(0,\ldots,0,j)$, i.e., the $j$-th input polynomial.

    - In practice, let $h_{k+1}$ be the polynomial in $\cal F$ with index $\mathbf{i}$ and compute
    $$
    s_{k+1} := \partial_{(h_1,\ldots,h_k), (i_1,\ldots,i_k), i_\ell} h_{k+1}.
    $$

    - Define the sets

      - $Y_{k+1} := \{ \mathbf{x} \in X' \mid s_{k+1}(\mathbf{x}) \ne 0 \}$ and

      - $U_{k+1} := \{ \mathbf{x} \in \R^n \mid h_{k+1}(\mathbf{x}) = 0, s_{k+1}(\mathbf{x}) \ne 0, g_1(\mathbf{x}) > 0 , \ldots, g_t(\mathbf{x}) > 0 \}$.

      - Note

        - Clearly $Y_{k+1} \subset X'$ and $Y_{k+1} \subset U_{k+1}$
        - $h_{k+1}(\mathbf{x}) = 0$ for all $\mathbf{x} \in Y_{k+1}$.
        - $U_{k+1}$ is a nonsingular subset of $\R^n$ having codimension $k+1$.

      - If $Y_{k+1}$ is an open subset of $U_{k+1}$, then $Y_{k+1}$ is smooth and has codimension $k+1$.

        - Let $X_{k+1} := X_{k+1} \cup Y$,

      - Otherwise, proceed by induction.

        - Compute
        $$(X^{\mathbf{m}}_{k+2},\ldots,X^{\mathbf{m}}_n) := {\rm Stratify}(k+1, F, (s,:\mathbf{h}), (i_\ell:\mathbf{i}), G)$$
        where $x:L$ denotes the `cons` operator. I.g., add $x$ to the beginning of list $L$.

      - Let $\rm{Empty}(X,s)$ be a subroutine returning *true* if $s \in \Z[x_1,\ldots,x_n]$ is identically zero on the set $X \subset \R^n$.

      - If $\rm{Empty}(X,s)$, we are finished.

        - Return
        $${\cal X}_{k+1} = (X_{k+1}, X_{k+1}, \ldots, X_n).$$
        where $X_i, k+2\le i \le n$ is the union of all strata $X^{\mathbf{m}}_i$ computed in the recursive calls.

      - Otherwise,

        - Let

          - $X' := \{ \mathbf{x} \in \R^n \mid s(\mathbf{x}) = 0 \}$,

          - ${\cal F} := {\cal F} \cup \{ ((0,\ldots,0,i_\ell,\ldots,i_{k+1},j), s) \}$,

        - $F := F:s$ (i.e., append $s$ to the end of list $F$).

      - Then proceed to the index immediately after $\mathbf{m}$ with respect to $\prec$.

      - The algorithm terminates when maximal index $M_j$ for every polynomial $f_j \in F$ has been considered.
:::

To call this algorithm on a semialgebraic set $X \subset \R^n$ defined by equations $F \subset \Z[x_1,\ldots,x_n]$ and $G \subset \Z[x_1,\ldots,z_n]$, compute
$$
{\cal X}' = {\rm Stratify}(0, F, (0), (0), G).
$$
to obtain a set of strata ${\cal X'} = (X_1, \ldots, X_n)$.
If all $X_i = \emptyset, 1 \le i \le k$, then we can conclude that every partial derivative vanishes identically on $X$. Hence, $X$ is a smooth subset of $\R^n$ and we let $X_0 = X$.
Otherwise, let $X_0 = \emptyset$ so that ${\cal X} = (\emptyset, X_1,\ldots,x_n)$ where each $X_i,1\le i \le n$ is a smooth subset of $X$ of codimension $i$, such that each $X_i,X_j,i\ne j$ is pairwise disjoint and $X_1\cup \ldots \cup X_n = X$.
Note, in the case that $X_0 = X$, the smooth stratification algorithm provides no information about the dimension of $X$.

### Subroutines and Algorithm Details { #sec:strat-algorithm-details }

The algorithm employs two subroutines, which were presented in the description as "black-box functions".
The first of these is a subroutine which determines whether $Y_k$ is an open subset of $U_k$.
This is the case if, for every point $\mathbf{x}$ in $Y_k$ all points of $U_k$ which are sufficiently close to $\mathbf{x}$ are also in $Y_k$.
This can be expressed as a first-order Boolean formula with two quantifier alternations and its truth value can be determined by performing quantifier elimination. I.e., $Y_k$ is an open subset of $U_k$ if
$$
\forall \mathbf{x} \in Y_k \> \exists \varepsilon > 0 \in \R \> \forall \mathbf{y} \in U_k \mid \Vert \mathbf{x} - \mathbf{y} \Vert < \varepsilon \rightarrow \mathbf{y} \in Y_k
$$
An alternative method, as described in @gv1995, Theorem 2, is to check whether every derivative computed at step $k+1$ vanishes on the set
$$
U_k \cap \{ x_1 = \tt{const} \mid i < i_1 \}
$$
where $i_k \in \{1,\ldots,n\}$ is a parameter passed from step $k$ to $k+1$ in the algorithm.
This, again, reduces to the emptiness check.

The second of these is $\rm{Empty}(S)$, where $S \subset \R^n$ is a semialgebraic set represented by a quantifier-free Boolean formula which is a conjunction of polynomial equations, inequations and inequalities. Note that an inequation $\{ f(\mathbf{x}) \ne 0 \}$ can be rewritten as $\{ f(\mathbf{x}) < 0 \lor f(\mathbf{x}) > 0 \}$, so it is possible to represent $S$ by two systems of polynomial equations and inequalities, or a Boolean formula containing the conjunction above. This permits various methods for checking emptiness. We may write $\rm{Empty}(S)$ as a quantifier elimination problem
$$
\exists \mathbf{x} \in \R^n \mid f_1(\mathbf{x}) = \ldots = f_s(\mathbf{x}) = 0, s_1(\mathbf{x}) \ne 0, \ldots, s_k(\mathbf{x}) \ne 0, g_1(\mathbf{x}) > 0, \ldots, g_t(\mathbf{x}) > 0.
$$
This problem can be decided using the singly-exponential quantifier elimination algorithm from Proposition \@ref(prp:bpr-qe) (@bpr2006, Algorithm 14.21), which, with one quantifier alternation, has complexity $(sd)^{O(n)}$ where $s$ is the number of different polynomials defining the set and $d$ their maximum degree -- singly exponential in the number of variables. Alternatively, the algorithm presented by @bpr98, which produces a witness point in every cell in a decomposition of the input set, may be used to decide emptiness. This algorithm also has complexity $(sd)^{O(n)}$.
In practice, quantifier elimination can be performed using CAD. This, of course, has complexity doubly exponential in the number of variables: $(sd)^{O(1)^n}$ (see Proposition \@ref(prp:collins)).

The algorithm may be implemented as above, but with some small tweaks to simplify the code and make the algorithm work slightly more efficiently.
First, observe that not all derivatives are needed to define the candidate stratum $Y_k$. One obvious situation is when a derivative $s_k$ turns out to be a nonzero constant $c \in \A$.
In the formula for $Y_k$, the inequation $c \ne 0$ will appear, which is obviously true. Since $X' \supset Y_k$ was assumed to be non-empty, we can immediately conclude that $Y_k$ is non-empty and equal to $X'$. No further derivatives at step $k$ need to be considered, since $X' \setminus Y_1 = \emptyset$.
A similar situation may arise, even with nonconstant functions $s_k$. For example, for the input set
$$
X := \{ \mathbf{x} \in \R^2 \mid x^2 y^2 = 0 \},
$$
the derivative for index $(0,1)$ is $\partial (x^2 y^2) / \partial x_1 = 2x y^2$, which is equal to zero at every point of $X$.
By discarding these redundant functions, we minimise the number of polynomials defining sets in the emptiness check. Note that we have to keep track of every derivative computed, even the redundant ones, so that we can find the function $h_k$ such that $s_k = \partial_{\mathbf{h}, \mathbf{i}, j} h_1$.

Now consider the operation of finding the derivative with index $(0,\ldots,0,i_\ell - 1,i_{\ell - 1}, \ldots, i_{k+1},j)$. The following observation allows us to quickly find this polynomial, avoiding a search in $\cal G$ or unnecesary recomputation of derivatives.
Suppose we are considering index
$$
\mathbf{m} = (0,\ldots,0,i_\ell,i_{\ell - 1},\ldots,i_{k+1},j)$$
and want to find the derivative with index
$$
\mathbf{j} = (0,\ldots,0,i_\ell - 1,i_{\ell - 1},\ldots,i_{k+1},j).$$
The set $\cal G$ includes polynomials computed in previous rounds of induction and those with index $\mathbf{i} \prec \mathbf{m}$, since we proceed in ascending lexicographical order. Hence $\cal G$ contains the derivative with index $\mathbf{j}$.
There is a convenient way to find this derivative.
Let us first illustrate the process with an example. Let $f_j \in \Z[x_1,x_2,x_3]$ with $M_j = (1,2,2)$ and consider the lexicographically ordered list of indices
$$
\begin{matrix}
L_1 :=\ &  (0,0,0),&(0,0,1),&(0,0,2),&(0,1,0),&(0,1,1),&(0,1,2),&(1,0,0),&(1,0,1)&\ldots\\
L_2 := \ & & (0,0,0),&(0,0,1),&(0,0,0),&(0,0,1),&(0,0,2),&(0,0,0),&(0,0,1)&\ldots.\\
\end{matrix}
$$
Observe that for indices of the kind $(0,\ldots,0,1,0,\ldots,0)$ in $L_1$, the corresponding element of $L_2$ is $(0,\ldots,0)$. For an arbitrary index $(0,\ldots,0,i_\ell,\ldots,i_1)$ in $L_1$ which appears $k$ elements after $(0,\ldots,0,i_\ell = 1,0,\ldots,0)$, the corresponding element in $L_2$ appears $k$ elements after $(0,\ldots,0)$.
From this, we can introduce an "index chasing" method as follows. Let ${\cal G}_j$ be the (ordered) list of derivatives of polynomial $f_j$. For each $\mathbf{m}$, we keep a pointer, ${\cal G}'_j$, to the element in ${\cal G}_j$ with index $\mathbf{j}$.

- Initialise ${\cal G}_j = ((0,\ldots,0),f_j)$. For $\mathbf{m} = (0,\ldots,0,1)$, set ${\cal G}'_j = {\cal G}_j$.
- Now suppose that ${\cal G}_j$ contains all polynomials with index $\prec \mathbf{m}$.
  - If $\mathbf{m} = (0,\ldots,0,1,0,\ldots,0)$, then $\mathbf{j} = (0,\ldots,0)$ and we set ${\cal G}'_j$ to the head of ${\cal G}_j$.
  - Otherwise, let ${\cal G}'_j$ be the tail of ${\cal G}'_j$.

The "index chasing" method works efficiently in SACLIB, which uses linked lists. However, we do need to append new derivatives to the end of ${\cal G}_j$, which takes $O(n)$ steps.
To avoid this, we keep a pointer to the last-but-one element in the list, i.e., suppose $G_j = (a_1,(\ldots,(a_{r-1},(a_r,(\rm{NIL})))\ldots)$ then $G_{j,\rm{append}} = (a_{r-1},(a_r,(\rm{NIL})))$. Then, if we wish to append $b$ to the end of $G_j$, we simply need to set the tail of $G_{j,\rm{append}}$ to $(a_r,(b,(NIL)))$.

We can also optimise the construction of the matrix associated to the partial differential operator $\partial_{\mathbf{h},\mathbf{i},j} f$. In this matrix,
$$
\begin{pmatrix}\dfrac{\partial h_{1}}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial h_{1}}{\partial x_{i_{k}}} & \dfrac{\partial h_{1}}{\partial x_{j}}\\
 & \vdots\\
\dfrac{\partial h_{k}}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial h_{k}}{\partial x_{i_{k}}} & \dfrac{\partial h_{k}}{\partial x_{j}}\\
\dfrac{\partial f}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial f}{\partial x_{i_{k}}} & \dfrac{\partial f}{\partial x_{j}}
\end{pmatrix},
$$
only the last row depends on $f$ and only the last column depends on $j$. Thus, we can save the $(k\times k)$-submatrix consisting of the first $k$ rows and columns and only append the new row and column. This matrix can be passed as an argument to ${\rm Stratify}(k,\ldots)$, with the matrix for $k=0$ being empty (i.e., $\mathbf{h} = \mathbf{i} = ()$ in the partial differential operator).

## Worked example { #sec:strat-worked-example }

We illustrate the smooth stratification algorithm with a worked example in $\R^3$. Consider
$$
\{ x_3 = 0, x_1^2-x_2^2=0 \} \subset \R^3.
$$
This set is contained in the plane $\{ x_3 = 0 \}$ and consists of the two intersecting straight lines $\{ x_1 - x_2 = 0 \}$ and $\{ x_1 + x_2 = 0 \}$ in $\opspan{x_1,x_2}$.
Note that the algorithm imposes an order on polynomials. Here we take $f_1 := z$ and $f_2 = x^2 - y^2$, wiht $f_1$ and $f_2$ being assigned indices $(0,0,0,1)$ and $(0,0,0,2)$ respectively.
The algorithm proceeds as follows

\begin{align}
k=0,X'&:=\left\{ \mathbf{x}\in\mathbb{R}^{3}\mid x_{3}=0,x_{1}^{2}-x_{2}^{2}=0\right\} \\\left(0,0,1,1\right)\ h_{1}&=f_{1}=x_{3}\\s_{1}=\partial f_{1}/\partial x_{1}&=0\\Y_{1}&:=\left\{ \mathbf{x}\in X'\mid0\ne0\right\} =\emptyset\\(0,0,1,2)\ h_{1}&=f_{2}=x_{1}^{2}-x_{2}^{2}\\s_{1}=\partial f_{2}/\partial x_{1}&=2x_{1}\\Y_{1}&:=\left\{ \mathbf{x}\in X'\mid2x_1\ne0\right\} \\U_{1}&:=\left\{ \mathbf{x}\in\mathbb{R}^{3}\mid x_{1}^{2}-x_{2}^{2}=0,2x_{1}\ne0\right\} \\&\text{Not open, proceed by induction}\\
k=1,h_{1}=f_{2},i_{1}=1,X''&:=Y_{1},F=\left\{ f_{1}=x_{3},f_{2}=x_{1}^{2}-x_{2}^{2}\right\} \\\left(0,1,1\right)\ h_{2}&=f_{1}\\s_{2}&=0\text{ since }f_{1}\text{ doesn't depend on }x_{1},x_{2}\\\left(0,1,2\right)\ h_{2}&=f_{2}\\s_{2}&=0\text{ snce }h_{1}=h_{2}\\\left(1,0,1\right)\ h_{2}&=f_{1}\\s_{2}=\det\begin{pmatrix}\partial h_{1}/\partial x_{1} & \partial h_{1}/\partial x_{3}\\
\partial h_{2}/\partial x_{1} & \partial h_{2}/\partial x_{3}
\end{pmatrix}&=\det\begin{pmatrix}2x_{1} & 0\\
0 & 1
\end{pmatrix}=2x_{1}\\Y_{2}&:=\left\{ \mathbf{x}\in X''\mid2x_{1}\ne0\right\}\\U_{2}&:=\left\{ \mathbf{x}\in\mathbb{R}^{3}\mid x_{1}^{2}-x_{2}^{2}=0,x_{3}=0,2x_{1}\ne0\right\} \\\text{Note }&Y_{1}=Y_{2}=U_{2}\\Y_{2}&\text{ is smooth and has codimension }2\\\text{since }X''&:=\left\{ \mathbf{x}\in X''\mid2x_{1}=0\right\} =\emptyset\text{, we return to }k=0\\k=0,X'&:=\left\{ \mathbf{x}\in\mathbb{R}^{3}\mid x_{3}=0,x_{1}^{2}-x_{2}^{2}=0,2x_{1}=0\right\} \\\text{Obsrve }X'&=(0,0,0)\\\left(0,0,2,1\right)\ h_{1}&=0,s_{1}=0\\\left(0,0,2,2\right)\ h_{1}&=2x_{1}\\s_{1}&=2\\Y_{1}&:=\left\{ \mathbf{x}\in X'\mid2\ne0\right\} =X'\\U_{1}&:=\left\{ \mathbf{x}\in\mathbb{R}^{3}\mid2x_{1}=0,2\ne0\right\} \\&\text{Not open, proceed by induction}\\
\end{align}

\begin{align}
k=1,h_{1}=2x,i_{1}=1,X''&:=Y_{1},F=\left\{ f_{1}=x_{3},f_{2}=x_{1}^{2}-x_{2}^{2},f_{3}=2x_{1}\right\} \\\left(0,1,1\right)\ h_{2}&=f_{1}=x_{3}\\s_{2}&=0\\\left(0,1,2\right)\ h_{2}&=f_{2}=x_{1}^{2}-x_{2}^{2}\\s_{2}=\det\begin{pmatrix}\partial h_{1}/\partial x_{1} & \partial h_{1}/\partial x_{2}\\
\partial h_{2}/\partial x_{1} & \partial h_{2}/\partial x_{2}
\end{pmatrix}&=\det\begin{pmatrix}2 & 0\\
2x_{1} & 2x_{2}
\end{pmatrix}=4x_{2}\\Y_{2}&:=\left\{ \mathbf{x}\in X''\mid4x_{2}\ne0\right\} =\emptyset\\\left(0,1,3\right)\ h_{2}&=f_{3}=2x_{1}\\s_{2}&=0\\\left(1,0,1\right)\ h_{2}&=f_{1}=x_{3}\\s_{2}=\det\begin{pmatrix}\partial h_{1}/\partial x_{1} & \partial h_{1}/\partial x_{3}\\
\partial h_{2}/\partial x_{1} & \partial h_{2}/\partial x_{3}
\end{pmatrix}&=\det\begin{pmatrix}2 & 0\\
0 & 1
\end{pmatrix}=2\\Y_{2}&:=\left\{ \mathbf{x}\in X''\mid2\ne0\right\} =X''\\U_{2}&:=\left\{ \mathbf{x}\in\mathbb{R}^{3}\mid2x_{1}=0,x_{3}=0\right\} \\&\text{Since }i_{2}=3\text{ it is impossible to compute further derivatives.}\\&\text{We conclude that}\\Y_{2}&\text{ is smooth and has codimension }3.
\end{align}

As expected, the algorithm outputs the set of strata
\begin{align*}
\mathcal{X}_{1}:=&\emptyset\\\mathcal{X}_{2}:=&\left\{ x_{1}^{2} - x_{2}^{2}=0,x_{3}=0,2x_{1}\ne0\right\} \\\mathcal{X}_{3}:=&\left\{ (0,0,0)\right\}
\end{align*}

## Optimisation of the Output

### Determining the codimension and basic formula for each stratum

@gv1995, Theorem 2 assert that each stratum of codimension $k$ can be represented by a conjunction containing $k$ equations. I.e., each stratum is basic. A naive implementation of the procedure leads to a non-basic representation as shown in the following example

::: {.example}
Consider the semialgebraic set
$$
S := \{ (x_1,x_2) \in \R^2 \mid x_1 x_2 = 0 \}
$$
Apply the algorithm.
\begin{align*}
k=0,X':=&\left\{ \mathbf{x}\in\mathbb{R}^{2}\mid f_{1}:=x_{1}x_{2}=0\right\} \\\left(0,1,1\right)h_{1}=&f_{1}=x_{1}x_{2}\\s_{1}=\partial f_{1}/\partial x_{1}=&x_{2}\\Y_{1}:=&\left\{ \mathbf{x}\in X'\mid y\ne0\right\} \\U_{1}:=&\left\{ \mathbf{x}\in \mathbb{R}^2\mid x_{1}x_{2}=0,x_{2}\ne0\right\} \\&\text{Proceed by induction}\\
k=1,h_{1}=f_{1},i_{1}=1,X'':=&Y_{1},F_{1}=\left\{ f_{1}\right\} \\\left(1,1\right),h_{2}=&f_{1}\\s_{2}=&\begin{pmatrix}\partial f_{1}/\partial x_{1} & \partial f_{1}/\partial x_{2}\\
\partial f_{2}/\partial x_{1} & \partial f_{1}/\partial x_{2}
\end{pmatrix}=0\\&\text{since both columns are equal.}\\\text{Return. }Y_{1}&\text{ is smooth.}\\
\end{align*}

Observe that the formula for $Y_1$ contains one equation, $h_1 = f_1$. Hence $Y_1$ is a smooth stratum in basic representation and we can conclude that it has codimension $1$.

For the next nonzero derivative, with index $(1,0,1)$, we get
\begin{align*}
k=0,X':=&\left\{ \mathbf{x}\in\mathbb{R}^{2}\mid x_{1}x_{2}=0,y=0\right\} \\\left(1,0,1\right)\ h_{1}=&f_{1}=x_{1}x_{2}\\s_{1}=\partial f_{1}/\partial x_{2}=&x_{1}\\Y_{1}:=&\left\{ \mathbf{x}\in X'\mid x_{1}\ne0\right\} \\U_{1}:=&\left\{ \mathbf{x}\in\mathbb{R}^{2}\mid x_{1}x_{2}=0,x_{1}\ne0\right\} \\&\text{Proceed by indection.}\\k=1,h_{1}=f_{1},i_{1}=2,X'':=&Y_{1}\ldots\\&\text{No partial derivatives can be computed.}\\\text{Return. }Y_{1}&\text{ is smooth.}
\end{align*}

Notice that the inductive step returns immediately. This is because $i_1=2$, so it is not possible to take further partial derivatives with respect to $j > i_1$. In the formula for
$$
Y_1 := \{ \mathbf{x} \in \R^2 \mid f_1 := x_1 x_2 = 0, h_1 := x_2 = 0, x_1 \ne 0 \},
$$
two different equations, $f_1$ and $h_1$ appear. However, $Y_1$ is not in basic representation. Indeed, the equation $f_1=0$ is redundant, since $f_1$ is equal to zero for all points at which $h_1$ is equal to zero. Thus $f_1$ can be discarded, and we see that only one equation, $h_1$, is required to represent $Y_1$ in basic form. We can conclude that $Y_1$ is smooth and has codimension $1$.

Finally, consider the derivative with index $(1,1,1)$.
\begin{align*}
k=0,X':=&\left\{ \mathbf{x}\in\mathbb{R}^{2}\mid x_{1}x_{2}=0,x_{2}=0,x_{1}=0\right\} \\\left(1,1,1\right)\ h_{1}=&s_{1}^{\left(0,1,1\right)}=x_{2}\\s_{1}=\partial f_{1}/\partial x_{2}=&1\\Y_{1}:=&\left\{ \mathbf{x}\in X'\mid1\ne0\right\} \\U_{1}:=&\left\{ \mathbf{x}\in\mathbb{R}^{2}\mid x_{2}=0,1\ne0\right\}
\end{align*}
Again, the inductive step returns immediately because $i_1=2$, but this time we can see that $Y_1$ is not an open subset of $U_1$. As mentioned above, the algorithm is unable to determine this without solving a quantifier elimination problem. Instead, we may be able to determine the codimension by looking at the basic representation of $$
Y_1 := \{ (x_1,x_2) \in \mathbb{R}^2 \mid x_1 x_2 = 0, x_1 = 0, x_2 = 0 \}.
$$
(Note that the constraint $1 \ne 0$ is dropped since it is trivial and adds no information.)
We see that three equations appear in the definition of $Y_1$, but the first one, $f_1 := x_1 y_2$ is redundant again. Thus, the two equations $x_2 = 0, x_1 = 0$ define $Y_1$ and we can conclude that $Y_1$ is smooth and has codimension $2$.
:::

This example shows two things. Firstly, not all functions are required to represent the smooth stratum and secondly $k$, the current step of induction, gives a lower bound on the codimension of strata.
@gv1995, Theorem 2 states that
$$
\det\begin{pmatrix}\partial h_{1}/\partial x_{i_{1}} & \ldots & \partial h_{1}/\partial x_{i_{k}}\\
\vdots &  & \vdots\\
\partial h_{k}/\partial x_{i_{1}} & \ldots & \partial h_{k}/\partial x_{i_{k}}
\end{pmatrix}\ne0
$$
at every point of a stratum $X_k$ of codimension $k$ which includes the functions $h_1,\ldots,h_k$ in its definition.
As we saw in the example, other functions vanish at every point of $X_k$. We need to find the "basic" set of $k$ functions needed to define $X_k$.

### Discarding redundant equations

Let $F \subset \Z[x_1,\ldots,x_n]$ be a set of polynomials, indexed by $(m_{i_1},\ldots,m_1,j)$ and, for $\mathbf{m} = (0,\ldots,0,m_\ell,\ldots,m_1,j),\ell > i_1$ let
$$
s^{m_n,\ldots,m_1,j}_k = \partial_{\mathbf{h}, \mathbf{i}, n}^{m_n} \partial_{\mathbf{h}, \mathbf{i}, i_1 + 1}^{m_{i_1 + 1}} f
$$
be the partial derivative computed at index $\mathbf{m}$, where $f \in F$ has index $(m_1,\ldots,m_1,j)$ be one of the partial derivatives computed during the algorithm.
Denote by $G$ the set of derivatives with index lexicographically less than $\mathbf{m}$. $Y_k \subset Y_{k-1}$ is defined such that every function in $G$ is equal to zero while the function $h^{\mathbf{m}}_k$ is not.
Define the smooth manifold
$$
U_k := \{ \mathbf{x} \in \R^n \mid h_1(\mathbf{x}) = 0, \ldots, h_{k-1}(\mathbf{x}) = 0, h_k(\mathbf{x}) = 0, s^{\mathbf{m}}_k(\mathbf{x}) \ne 0 \}.
$$
of codimension $k$, where the function $h_k := s^{(0,\ldots,0,m_\ell - 1,m_{\ell - 1},\ldots,m_1,j)}_k$. According to @gv1995, Theorem 2, $Y_k$ is smooth and has codimension $k$ if it is an open subset of $U_k$. In this case, only $k$ of the polynomials will be needed to define $Y_k$. Note that inequations $s_1,\ldots,s_{k-1}$ which appear in the definition of $Y_{k-1} \supset Y_k$ should also be taken into account.
Begin with a set
$$
Y' := \{ \mathbf{x} \in \R^n \mid h_1(\mathbf{x}) = 0, \ldots, h_{k-1}(\mathbf{x}) = 0, s_1(\mathbf{x}) \ne 0, \ldots, s_(\mathbf{x}) \ne 0, s_k(\mathbf{x}) \ne 0 \} \subset Y_k.
$$
Consider each function $g \in G$ in reverse lexicographical order. If $g(\mathbf{x}) = 0$ at every point $\mathbf{x} \in Y'$ then it is redundant and should be discarded. Otherwise, $g$ should be included in the defining equations for $Y_k$. Since $Y_k$ has codimension $k$, and $Y'$ is already an open, basic set of codimension $k-1$, only one more polynomial should be needed.
If $Y_k$ is not an open subset of $U_k$, then more polynomials will be required to define it, and the number of polynomials gives the codimension.

A polynomial $g \in \Z[x_1,\ldots,x_n]$ is redundant in the definition of the semialgebraic set $S \subset \R^n$ if the following formula is true
$$
\exists x_1,\ldots,x_n,a \in \R^{n+1} \mid (x_1,\ldots,x_n) \in S, a \ne 0, g(x_1,\ldots,x_n) = a.
$$
This problem can also be formulated using the emptiness check. $g$ is redundant in the definition of $S$ if the semialgebraic set
$$
\{ \mathbf{x} \in S \mid g(\mathbf{x}) \ne 0 \}
$$
is non-empty.

<!-- TODO do we also need to check that the determinant of the matrix (minors?) is nonzero. -->

### From Basic Algebraic sets to Arbitrary Semialgebraic sets {#sec:strat-semialgebraic}

@gv1995, Corollary 1 asserts that the algorithm can be applied to arbitrary semi-pfaffian sets and, therefore, without modification, to arbitrary semialgebraic sets.
Let $S \subset \R^n$ be a semialgebraic set represented by a quantifier-free Boolean formula containing polynomials
$$
f_1,\ldots,f_s.
$$
Consider each "sign set"
$$
S_{( \ast_1,\ldots,\ast_s )} := \{ \mathbf{x} \in \R^n \mid f_1(\mathbf{x}) \ast_1 0, \ldots, f_s(\mathbf{x}) \ast_s 0 \}
$$
where $\ast_i, 1 \le i \le s \in \{<, >, =\}$. $S$ can be partitioned into a finite union of some of the $s^3$ sign sets.
If we apply the smooth stratification algorithm to each $S_{(\ast_1,\ldots,\ast_s)} \subset S$, and take the union of strata, we will obtain a smooth stratification of the set $S$. Indeed, since no two sign sets have non-empty intersection, it is clear that no two strata intersect, and since a finite number of the sign-sets form a partition of $S$, the smooth strata of these sign-sets also forms a partition of $S$.

### Implementation in C

This algorithm has been implemented in `C`, using the computer algebra library `SACLIB`. `QEPCAD` is used to perform emptyness checks using cylindrical algebraic decomposition. Below is an example of the program's output, given the basic semialgebraic set
$$
\{ z = 0, x^2 - y^2 = 0 \} \subset \R^3,
$$
discussed in Section \@ref(sec:strat-worked-example).

```
Enter a variable list.
(x,y,z)
Please enter a QEPCAD formula defining a basic semialgebraic set(i.e., conjunction of equations and inequalities).
[ z = 0 /\ x^2 - y^2 = 0 ].

Stratification computed. Please select an option.
  1. print all polynomials
  2. print all strata
  0. exit

1
All polynomials generated by the smooth stratification algorithm:
2 x
-y^2 + x^2
z
1
2 x
z
-y^2 + x^2

Stratification computed. Please select an option.
  1. print all polynomials
  2. print all strata
  0. exit
2
List of all strata.
Strata of codimension 1

Strata of codimension 2
X_(2,1):
  { z == 0
  , -y^2 + x^2 == 0
  , 2 x /= 0
  , 2 x /= 0
  }

Strata of codimension 3
X_(3,1):
  { -y^2 + x^2 == 0
  , z == 0
  , 2 x == 0
  }

```

The program works in a similar way to `QEPCAD` (see Section \@ref(sec:qepcad)), taking as input the variable list (which specifies the order) and a conjunction of polynomial equations, inequations and inequalities (written as a QEPCAD "prenex" formula). The stratification is then computed and there is a basic REPL which allows the user to see information about the polynomials and strata produced.

Exerpts of the code are now presented and discussed. The entrypoint for the algorithm is `stratify`.

**Input:**

- `Word r` $\in \Z$ (ambient dimension),
- `Word L` $= (f_1,\ldots,f_k) \subset \Z[x_1,\ldots,x_r]$,
- `Word Ineqs` $= (g_1,\ldots,g_\ell) \subset \Z[x_1,\ldots,x_r]$,
- `Word V` $= (v_1,\ldots,v_r)$ is a variable list,

such that $X = \{ f_1 = 0, \ldots, f_k = 0, g_1 > 0, \ldots, g_\ell = 0 \}$ is the basic semialgebraic set to be stratified.

**Output:**

- `Word S`: set of smooth strata $(\mathcal{X}_1,\ldots,\mathcal{X}_r)$, such that $\mathcal{X}_i$ contains strata of comidemnios $i$ for $1 \le i \le r$, or `NIL` if $X$ is a smooth subset.

``` {c, code-strat-main, eval=FALSE, attr.source='.numberLines' }
Word stratify(Word r, Word L, Word Ineqs, Word V, Word *S_)
{
    // initialise strata S
    *S_ = NIL;
    int i = 0;
    while (i < r) {
        *S_ = COMP(NIL, *S_);
        ++i;
    }

    // initialise the inequalities as a QEPCAD formula
    Word D, P;
    Word F = NIL;
    while (Ineqs != NIL) {
        ADV(Ineqs, &P, &Ineqs);

        F = COMP(LIST4(GTOP, P, r, NIL), F);
    }

    // initialise the input set of polynomials with their degrees
    Word Fs = NIL, s = 0;
    while (L != NIL) {
        ADV(L, &P, &L);
        ++s;

        D = DEG(r, P);
        Fs = COMP(LIST2(P, D), Fs);
    }

    // initial i0 = FIRST(I1) = 0. h0 = FIRST(Hs) = 0, Minor is the empty matrix
    int strata_appended;
    Word Gs = strat_helper(r, V, F, 1, s, Fs, LIST1(0), LIST1(0), NIL, NIL, &strata_appended, S_);

    if (strata_appended == 0) {
        // X is smooth
        *S_ = NIL;
    }

    return Gs;
}
```

This function sets up the data structures required by `stratify_helper`, the recursive function which performs stratification of some input set $X \subset \R^n$.

**Input:**

- `Word r` $\in \N$, `Word V`: variable list, Word Ineqs`: qepcad formula of inequalities $\{ g_1 > 0, \ldots, g_\ell >0 \}$,
- `Word k` $1\le k \le r$ is the codimension currently beind worked with,
- `Word np`: number of polynomials,
- `Word Fs` $((f_1,\deg(f_1)), \ldots, (f_{\rm{np}}, \deg(f_{\rm{np}})))$ is the list of imput polynomials,
- `Word Is` is a partial index $(0,,i_1,\ldots,i_{k-1})$,
- `Word Hs` is the set of polynomials $(h_{i_1},\ldots,h_{i_{k-1}})$,
- `Word Qs` is a list of polynomials $\subset \Z[x_1,\ldots,x_n]$,
- `Word Minor` is a $((k-1)\times (k-1))$-matrix $A = \vert a_{ij} \vert = \partial h_{i} / partial x_{j}$ for $h_i \in \rm{Hs}, j \in \rm{Is}$.

such that the input set $X$ is defined by equations `Fs` and `Hs`, inequalities `Ineqs` and inequations `Qs`.

**Output:**

- `Word Gs` $\subset \Z[x_1,\ldots,x_r]$ is the set of all partial differentials (for steps $k \le j \le r$),
- `int strat_count_` is the number of strata appended (for steps $k \le j \le r$),
- `Word S` is the set of strata (for steps $k \le j \le r$).

``` {c, code-strat-helper, eval=FALSE, attr.source='.numberLines' }
Word strat_helper(Word r, Word V, Word Ineqs, Word k, Word np, Word Fs, Word Is, Word Hs, Word Qs, Word Minor, int *strat_count_, Word *S_)
{
    // add constraints x_1 = 0, ..., x_{i1 - 1}  0
    Word i0 = FIRST(Is); // number of variables considered so far

    // base case for no polynomials?
    if (np == 0 || i0 >= r) {
        *strat_count_ = 0;
        return NIL;
    }

    // list of H polynomials (rev order) without the last (zero) one.
    Word Hs1 = RED(CINV(Hs));

    // set up return value
    Word Gs1 = NIL; // list of all differentials computed in this round, to return
    Word Gs2 = NIL; // list of differentials produced during induction
    Word Gs3 = NIL; // store Gs on current round

    // set up working array
    Word g_count = np; // how many differentials computed so far, index in Gs
    Word Gs = NIL; // list of all differentials computed in this round, working set

    // metadata
    Word Ms[np]; // number of steps before maximum differentiation variable (i1) should be incremented
    Word Dvs[np]; // list of current differentiation variable (i1)
    Word Backup[np]; // first polynomial in the list
    Word Chase[np]; // first element is h1
    Word ChaseIndex[np]; // chase array index of polynomial h1
    Word Append[np]; // pointer to last but one element in list, for quick appending.

    Word p_index = 0; // initial polynomial index, ranges over 0 <= p_index < np

    // initialise metadata for each input polynomial
    while (p_index < np) {
        Word F1;
        ADV(Fs, &F1, &Fs);

        Word D = REDI(SECOND(F1), i0);
        Ms[p_index] = COMP(1, LCOPY(D)); // neet do copy as we modify later
        Dvs[p_index] = i0;
        Backup[p_index] = F1;
        Chase[p_index] = F1;
        ChaseIndex[p_index] = 0;
        Append[p_index] = RED(F1);
        Gs = COMP(LCOPY(F1), Gs);
        Gs3 = COMP(FIRST(F1), Gs3);

        // increment index
        ++p_index;
    }

    // main loop, consider each index (j, m_{i0 + 1}, ..., m_r) in lex order
    Word n_finished = 0; // each polynomial has a different max index, keep track of how many indices are maxed out
    Word count = 0; // number of derivatives computed so far, scalar value of (m_{i0 + 1}, ..., m_r)

    int strat_count = 0;
    while (n_finished < np) { // stop once differential index for every polynomial is maxed
        // reached the end of polynomial list, cycle back to beginning and consider next differential index I
        if (p_index == np) {
            p_index = 0;
            n_finished = 0;

            ++count;
        }

        Word v = Dvs[p_index]; // differentiation variable
        Word m = FIRST(Ms[p_index]);

        // update variable v and chaser list
        if (count >= m && v == r) { // rollover, but we're finished
            ++n_finished; // this polynomial is done.
            ++p_index; // next polynomial

            continue; // skip it
        } else if (count >= m) { // rollover - increment differentiation variable
            ++v; // next variable ...
            Dvs[p_index] = v; // ... and store
            Chase[p_index] = Backup[p_index];
            ChaseIndex[p_index] = 0;

            // calculate next m
            Word M1 = RED(Ms[p_index]);
            Word d = FIRST(M1);
            SFIRST(M1, d * m);
            Ms[p_index] = M1;

            // degree zero - no derivatives taken for this variable. next iteration will increment the variable.
            if (d == 1) continue;
        }

        // next polynomial
        Word F1 = Append[p_index];

        // compute s_k = partial_{(h_1,...,h_{k-1}),(i_1,...,i_{k-1}),v} h_k
        // get h_k and its degree
        Word P;
        ADV(Chase[p_index], &P, &Chase[p_index]);

        // construct jacobi matrix using h1 = P and i1 = v
        Word Jacobi = JacobiFromMinor(r, P, v, Hs, Is, Minor);

        // compute partial differential, determinant of jacobi matrix
        // note that Q may be a constant, we need to preserve it
        Word Q = MAIPDE(r, Jacobi); // next derivative is the jacobi determinant
        Word Qdeg = DEG(r,Q);
        bool q_const = IPCONST(r, Q);
        Word Q1 = LIST2(Q, Qdeg);
        Word Qs1 = Qs;
        if (!q_const) Qs1 = COMP(Q, Qs1); // because c /= 0 is trivially true

        // candidate stratum Y1 on which Q /= 0
        //   - 0 /= 0 is trivially false, so we immediately conclude that it's empty
        //   - const /= 0 is trivially true, so assuming the algebraic set Gs3 is non-empty, Y1 is trivially non-empty
        //   - if Q is constant, Y1 must be the last candidate, since the next one includes a trivially false equation
        if (Q != 0 && (q_const || !ISEMPTY(r, V, Gs3, Qs1, Ineqs))) {
            // Gs2 contains derivatives computed during recursion
            int strata_appended;
            Gs2 = strat_helper(r, V, Ineqs, k + 1, g_count, Gs, COMP(v, Is), COMP(P, Hs), Qs1, Jacobi, &strata_appended, S_);
            Gs1 = CONC(Gs1, Gs2);

            // determine if all derivatives at step k+1 vanish on the set Y1
            strat_count += strata_appended;

            // append stratum if none were appended during induction
            if (strata_appended == 0) {
                Word Y, k1;
                construct_stratum_basic(k, r, V, Hs1, Q, Qs, Gs3, Ineqs, &k1, &Y);
                append_stratum(S_, k1, Y);
                ++strat_count;
            }

            Gs3 = COMP(Q, Gs3);
            Gs = COMP(Q1, Gs);
            ++g_count;

            if (q_const) {
                // the next candidate will include the trivially false eequation const = 0. stop.
                break;
            }
        }

        // append derivative to Fs, preserving zeroes
        SRED(F1, Q1);
        Append[p_index] = RED2(F1);

        // next polynomial please.
        Chase[p_index] = RED(Chase[p_index]);
        ChaseIndex[p_index] = ChaseIndex[p_index] + 1;
        ++p_index;
    }

    Gs1 = CONC(Gs1, Gs3);
    *strat_count_ = strat_count;
    return Gs1;
}
```

- For the base case, where there are no polynomials, or index $i_k \ge r$, (Line 7), there is nothing to do. No strata are appended and no polynomials computed.
- Prior to Line 57, initialisation is done. Metadata for each polynomial in `Fs` is stored.
- The main loop, beginning on Line 57, computes partial derivatives in ascending lexicographical order of index $(i_r,\ldots,i_{k+1},j)$, $1 \le j \le \rm{np}$.
- Lines 57-100 keeps track of the current polynomial `P` and "differentiation variable" `v` $\in x_{i_k+1},\ldots,i_r$.
- Line 101 calls the function `JacobiFromMinor`, which takes a $((k-1)\times (k-1))$-matrix $A = \vert a_{ij} \vert = \partial h_i / \partial x_j$, a polynomial $f$ and index $\ell$, and returns the $(k \times k)$-matrix obtained from $A$ by appending column $(\partial h_1 / \partial x_\ell, \ldots, \partial h_{k-1} / \partial x_\ell)^T$ and row $(\partial f / \partial x_{i_1}, \ldots, \partial f / \partial x_{i_{k-1}}, \partial f / \partial \ell)$. I.e., it constructs the matrix from the partial differential operator (Definition \@ref(def:pdo)) and saves recomputing the whole matrix of partial derivatives. Note that, when $k=1$, `JacobiFromMinor` returns the one-element matrix $\partial f / \partial \ell$.
- On line 105, the determinant of the matrix computed on Line 101 is calculated, for the partial differential operator.
- Line 116 determines if the candidate stratum is empty (see comment on Lines 112-115).
- If non-empty, we proceed by induction, calling `strat_helper` recursively (for $k+1$, appending index `v` and polynomial `P`, and passing the $(k \times k$-matrix as the `Minor`). The number of strata of codimension $> k$ which were added to `S` is returned. If no strata were appended, all the partial derivatives vanish identically on the candidate, and we can conclude that it is smooth and has codimension $k$.
- Line 128 represents the candidate stratum as a basic semialgebraic set containing $k$ equations. The function `construct_stratum_basic` is discussed shortly.
- The rest of the function is responsible for updating the metadata and keeping track of the list of polynomials `Gs1` to be returned.

The function `construct_stratum_basic` is responsible for representing a candidate stratum as a basic semialgebraic set defined using $k$ polynomial equations. It discards redundant polynomials as described in Section \@ref(sec:strat-algorithm-details).

**Input:**

- `Word r` $\in \N$: ambient dimension,
- `Word k` $0 \le k \le r$: codimension of candidate stratum,
- `Word V`: variable list,
- `Word Hs` $= (h_{i_1},\ldots,h_{i_{k-1}}) \subset \Z[x_1,\ldots,x_r]$,
- `Word Q` $\in \Z[x_1,\ldots,x_r]$,
- `Word Qs` $\subset \Z[x_1,\ldots,x_r]$,
- `Word Gs` $\subset \Z[x_1,\ldots,x_r]$,
- `Word Ineqs`: a QEPCAD formula of inequalities,

such that `Hs`, `Qs`, `Q`, `Gs` and `Ineqs` define a candidate stratum $Y_k$. All of `Hs` and `Gs` are equal to zero on $Y$, all of `Q` and `Qs` are not equal to zero on $Y$ and the formula `Ineqs` defines a semialgebraic set containing $Y$.

**Output**=

- `Word k1` $\ge$ `k` is the actual codimension of $Y$,
- `Word F` is the stratum $Y$ defined by `k1` equations and the inequations and inequalities from `Qs`, `Q` and `Ineqs`

``` {c, code-strat-basic, eval=FALSE, attr.source='.numberLines' }
void construct_stratum_basic(Word k, Word r, Word V, Word Hs, Word Q, Word Qs, Word Gs, Word Ineqs, Word *k1_, Word *Y_)
{
    Word L, P, i;
    Word Eqs = NIL, Ineqats = NIL;

    // we may have Q = const, if so don't include it.
    if (!IPCONST(r, Q)) {
        Qs = COMP(Q, Qs);
    }

    // add Qs and Hs to the definition of stratum
    L = Hs, i = k - 1;
    while (L != NIL) {
        // equation h = 0
        ADV(L, &P, &L);
        Eqs = COMP(P, Eqs);

       --i;
    }

    L = Qs;
    while (L != NIL) {
        // inequation s /= 0
        ADV(L, &P, &L);
        Ineqats = COMP(P, Ineqats);
    }

    // we start with functions (h_1,...,h_{k-1}) and then determine which ones from Gs are required.
    Word k1 = k - 1; // store the codimension.

    // attempt to add mroe polynomials from the list Gs of candidate functions.
    while (Gs != NIL) {
        ADV(Gs, &P, &Gs);

        if (!ISEMPTY(r, V, Hs, COMP(P, Qs), Ineqs)) {
            // if this set is non-empty, then there is a point at which P /= 0, thus P = 0 is necessary
            Hs = COMP(P, Hs);
            Eqs = COMP(P, Eqs);

            ++k1; // addition of a new polynomial increases the codimension
        }
    }

    // assign to return
    *k1_ = k1;
    *Y_ = LIST2(Eqs, Ineqats);
}
```

The idea is to use emptiness checking to find the minimal number, `k1` of equations needed to define the stratum $Y$ as a basic semialgebraic set. `k1` is the codimension of $Y$.

The function `ISEMPTY` performs emptiness checking.

**Input:**

- `Word r` $\in \N$,
- `Word V`: variable list $(x_1,\ldots,x_r)$,
- `Word Fs` $= (f_1,\ldots,f_s) \subset \Z[x_1,\ldots,x_r]$,
- `Word Gs` $= (h_1,\ldots,h_t) \subset \Z[x_1,\ldots,x_r]$,
- `Word Ineqs`: list of atomic QEPCAD formulas $\{ g_1 > 0 \},\ldots,\{ g_\ell > 0 \}$

such that the input set $S \subset \R^r$ can be defined by the QFF
$$
F = \{ f_1 = 0,\ldots,f_s = 0, h_1 \ne 0,\ldots,h_t \ne 0, g_1 > 0,\ldots,g_\ell > 0 \}
$$

**Output:**

- `true` if $S$ is empty, `false` otherwise.

``` {c, code-strat-isempty, eval=FALSE, attr.source='.numberLines' }
Word ISEMPTY(Word r, Word V, Word Fs, Word Gs, Word Ineqs)
{
    Word P, Ct, Cf;

    // start with the list of inequalities
    Word F = Ineqs;

    // add equations
    while (Fs != NIL) {
        ADV(Fs, &P, &Fs);

        F = COMP(LIST4(EQOP, P, r, NIL), F);
    }

    // and inequations
    while (Gs != NIL) {
        ADV(Gs, &P, &Gs);

        F = COMP(LIST4(NEOP, P, r, NIL), F);
    }

    // complete formula by adding the inequation and conujnction
    F = COMP(ANDOP, F);

    // re-initialise qepcad before each run
    QepcadCls Q;
	INITSYS();

    // set input formula
    Q.SETINPUTFORMULA(V,LIST4(r, r, NIL, F));
    Q.PRDQFF();
    Q.CADautoConst();

    // special case: trivially false
    if (Q.GVPC == 0) {
        return true;
    }

    LISTOFCWTV(Q.GVPC, &Ct, &Cf);

    /* compute cad */
    return Ct == NIL;
}

```

The function constructs $F$, the defining formula for $S$ and uses QEPCAD to construct a CAD of $\R^r$ compatible with $S$. If $S$ is empty, then this CAD will contain no true cells, so the function checks this condition.

## Complexity Analysis {#sec:strat-complexity}

We first briefly summarise the semi-Pfaffian case, as presented by @gv1995.
The algorithm from @gv1995, Theorem 2 takes as input a semi-Pfaffian set with the format $(r, N, \alpha, \beta, n)$ (see Definition \@ref(def:pfaff-format)) and has a complexity upper bound of
$$
3^N N^{n+1} {\cal B}
$$
where
$$
{\cal B} = (\alpha + \beta + 1)^{(r+1)^{O(n)}}.
$$
Without the Oracle, the total number of strata, some of which may be empty, does not exceed $N^{n+r}{\cal B}$, each of which has format $(r, N{\cal B},\alpha, {\cal B}, n)$.
If the Oracle, used for checking emptiness, is allowed, then the algorithm has complexity not exceeding $N^{n+r}{\cal B}$.

Now consider this algorithm applied to the semialgebraic set
\begin{equation}
X := \{ \mathbf{x} \in \R^n \mid f_1 = 0, \ldots, f_k = 0, g_1 > 0, \ldots, g_\ell > 0 \},
(\#eq:strat-imput-set)
\end{equation}
where all $s := k + \ell$ functions $f_i,g_j$ are polynomials with maximum degree $d$ -- Pfaffian functions of order $0$ and degree $(\alpha, \beta)$.
The upper complexity bound for the algorithm without Oracle is
$$
3^{s} s^{n+1} (d + 1)^2.
$$
The number of strata, some of which may be empty, does not exceed
$$s^{n} (d + 1)^2.$$
Each stratum is defined by at most $s (d + 1)^2$ polynomial equations and inequalities of maximum degree $(d + 1)^2$.
If the Oracle is allowed, no empty strata will be produced and the algorithm has complexity not exceeding
$$
s^{n+1} (d + 1)^2.
$$
These bounds follow immediately from @gv1995, Theorem 6.2.
We will now analyse the complexity of the algorithm presented in Section \@ref(sec:strat-alg-description), which performs emptiness checking on candidate strata.

There are $s^{n} (d + 1)^2$ candidate strata $Y_k$, and the algorithm determines whether each of them is empty, in order to decide whether all partial differential equations vanish identically on the input set $X$.
In the implementation, the check is done using CAD (a call to `QEPCAD-B`).
For the purposes of complexity analysis, we will use a theoretical algorithm, having singly exponential complexity in the number of variables.
@bpr98 propose an algorithm which takes a semialgebraic set $S \subset \R^n$ defined by $s$ polynomials with maximum degree $d$ in $n < s$ variables and produces a "witness" -- a point contained in every cell in a decomposition of $S$.
The algorithm can be used to determine the emptiness of $S$ and requires $s(s/n)^n d^{O(n)}$ arithmetic operations.
This is asymptotically the same as $$(sd)^{O(n)}.$$
Using the bounds for the number and degrees of polynomials defining strata, each emptiness check costs
$$
\left(s(d+1)^{2}(d+1)^{2}\right)^{O(n)}=\left(s(d+1)^{4}\right)^{O(n)},
$$
which is asymptotically the same as
$$
\left(s(d+1)\right)^{O(n)}
$$
This operation must be performed for all of the
$s^{n} (d + 1)^{2}$
candidate strata, resulting in a total complexity for emptiness checking of
$$
\left(s(d+1)\right)^{O(n)^{2}}.
$$
The total complexity of stratification, given by the sum of the complexity of applying the algorithm and performing the emptiness checks, is
$$
3^{s}s^{n+1}(d+1)^{2}+\left(s(d+1)\right)^{O(n)^{2}}.
$$
Since $s^{n+1}(d+1)^{2}$ is bounded from above by $\left(s(d+1)\right)^{O(n)^{2}}$, we get a total complexity upper bound of
$$
3^{s}\left(s(d+1)\right)^{O(n)^{2}}.
$$

## Test Cases

Some test cases are now presented

1.

  - **Input:** $(x,y), \{ xy = 0 \}$

  - **Output:**

    ```
    X_(1,1):
      { y == 0
      , x /= 0
      }
    X_(1,2):
      { x y == 0
      , y /= 0
      }

    Strata of codimension 2
    X_(2,1):
      { y == 0
      , x == 0
      }
    ```

1.

  - **Input:** $(x,y), \{ x^5 y^4 = 0 \}$

  - **Output:**

    ```
    Strata of codimension 1
    X_(1,1):
      { 120 y^4 == 0
      , 24 x^5 /= 0
      }
    X_(1,2):
      { x^5 y^4 == 0
      , 120 y^4 /= 0
      }

    Strata of codimension 2
    X_(2,1):
      { 120 y^4 == 0
      , 24 x^5 == 0
      }
    ```

1.

  - **Input:** $(x,y) x^2 + y^2 = 1$

  - **Output:**

    ```
    Strata of codimension 1
    X_(1,1):
      { y^2 + x^2 - 1 == 0
      , 2 x /= 0
      }

    Strata of codimension 2
    X_(2,1):
      { y^2 + x^2 - 1 == 0
      , 2 x == 0
      , 4 y /= 0
      }

    ```

1.

  - **Input:** $(x,y) (x^2 + y^2 - 1)(x^2 - y^2) = 0$ *(unit circle plus a cross)*

  - **Output:**

    ```
    Strata of codimension 1
    X_(1,1):
      { y^4 + 2 x^2 y^2 - y^2 + x^4 - x^2 == 0
      , 4 x y^2 + 4 x^3 - 2 x /= 0
      }

    Strata of codimension 2
    X_(2,1):
      { 16 y^5 + 32 x^2 y^3 - 16 y^3 + 16 x^4 y - 16 x^2 y + 4 y == 0
      , 4 x y^2 + 4 x^3 - 2 x == 0
      , 4 y^2 + 12 x^2 - 2 /= 0
      , 320 y^6 + 832 x^2 y^4 - 352 y^4 + 704 x^4 y^2 - 576 x^2 y^2 + 112 y^2 + 192 x^6 - 224 x^4 + 80 x^2 - 8 /= 0
      }
    X_(2,2):
      { y^4 + 2 x^2 y^2 - y^2 + x^4 - x^2 == 0
      , 4 x y^2 + 4 x^3 - 2 x == 0
      , 4 y^2 + 12 x^2 - 2 /= 0
      , 16 y^5 + 32 x^2 y^3 - 16 y^3 + 16 x^4 y - 16 x^2 y + 4 y /= 0
      }

    ```

1.

  - **Input:** $(x,y,z), x y z = 0$

  - **Output:**

    ```
    Strata of codimension 1
    X_(1,1):
      { z == 0
      , x y /= 0
      }
    X_(1,2):
      { y z == 0
      , x z /= 0
      }
    X_(1,3):
      { x y z == 0
      , y z /= 0
      }

    Strata of codimension 2
    X_(2,1):
      { z == 0
      , x y == 0
      , y /= 0
      }
    X_(2,2):
      { y z == 0
      , x z == 0
      , z /= 0
      }

    Strata of codimension 3

    ```

1.

  - **Input:** $(x,y,z) x^2 + y^2 + z^2 = 0$

  - **Output:**

    ```
    Strata of codimension 1

    Strata of codimension 2

    Strata of codimension 3
    X_(3,1):
      { z^2 + y^2 + x^2 == 0
      , 4 y == 0
      , 2 x == 0
      }

    ```
<!---
1.

  - **Input:** $(x,y) x^2 + y^2 = 1$

  - **Output:**
-->

