# Smooth Stratification {#sec:smooth-strat}

Before turning our attention to cylindrical decompositions, we will present another useful algorithm for decomposing a semialgebraic set.
A smooth stratification is a finite partition of a set into smooth manifolds (see Definition \@ref(def:analytic-submanifold)).
This algorithm will form part of the later work in constructing a CAD with monotone cells, which requires the input sets
to first be partitioned into smooth manifolds (see Chapter \@ref(sec:quasi-affine)). However, the algorithm and implementation described in this section are useful in their own right.

In 1957, @whitney1992 proved that every real algebraic variety -- the set of real solutions to a system of multivariate polynomial equations -- can be partitioned into a finite set of smooth manifolds, each of which is a semialgebraic set.
Lojasiewicz extended this result by proving that every real semianalytic set admits a smooth stratification, such that every stratum is a semianalytic set [@lojasiewicz1964]. However, the proof was non-constructive and did not provide any information on the class of functions defining the strata.
As part of his Complement Theorem, @gabrielov1996 proved that the strata of a semianalytic set can be defined by functions belonging to the smallest extension of a family of functions defining the set which is closed under addition, multiplication and taking partial derivatives. One such class of functions is the Pfaffian functions.
@gv1995 present an algorithm for computing a smooth stratification of a semi-Pfaffian set, along with an estimate of its complexity and bounds on the formats of the strata it produces. This algorithm (also summarised in @gv04, Section 6) will be presented with a focus on the semialgebraic case.
As far as we are aware, this is the first time this algorithm has been presented in the form of pseudo-code. In addition the implementation described in this chapter, along with the optimisations used for tracking the partial derivatives and constructing the matrix associated with the partial differential operator, is the first of its kind. Bounds, specific to the semialgebraic case, are also obtained.

We first state some definitions.

::: {.definition}
(Reproduced from Definition \@ref(def:eff-non-sing))

A smooth manifold $X_k \subset \R^n$ of codimension $k$ is called effectively nonsingular if the system of equations and inequalities defining it includes a set of $k$ Pfaffian functions
$h_{i_1}, \ldots , h_{i_k}$ such that the restriction $h_{i_j}\vert_{X_i} = 0$ and $d h_{i_j} \ne 0$ at every point $\mathbf{x} \in X_k$, for each $1 \le j \le k$.
:::

::: {.definition #weak-strat}
[@gv04, Definition 6.2]

A weak stratification of a semi-Pfaffian set $X \subset \R^n$ is a partition of $X$ into a finite number of smooth manifolds $X_k, 0 \le k \le n$ called strata. Strata need not be connected (or even have a finite number of connected components) and may be empty.

The stratification is called basic if all strata are basic semi-Pfaffian sets (see Definition \@ref(def:semi-pfaff)) which are effectively nonsingular (see Definition \@ref(def:eff-non-sing)).
:::

Note that this definition does not guarantee any other desirable properties of the manifolds $X_k$. E.g., the closure of a stratum may not be a union of strata.

## Algorithm desccription { #sec:strat-alg-description }

Since every semialgebraic set is a semi-Pfaffian set, this algorithm can be applied to the semialgebraic sets with almost no modifications.
The algorithm described by @gv1995 makes use of an oracle -- a hypothetical black-box function which performs a given computation in one step -- to determine whether a semi-Pfaffian set is empty.
Since each stratum is defined by sign conditions on partial derivatives of input functions, it is clear that if the input set is semialgebraic, then each stratum will be semialgebraic, too.  Furthermore, as emptiness of semialgebraic sets can be decided, e.g., using the cylindrical algebraic decomposition algorithm, an oracle will not be needed in this variation of the algorithm.
The algorithm relies on computing partial derivatives of the functions defining the input set. In the semi-Pfaffian case, the number of partial derivatives which must be considered is bounded by the format of the input set. As every polynomial has  a finite number of partial derivatives, the bound for the semialgebraic case will simply be the degree of the polynomial.

We will need the following notation for partial derivatives and the partial differential operator defined by @gv1995.

::: {.definition #pdo }
[@gv1995, Definition 2]

Let $f \in \Z[x_1,\ldots,x_n]$ be a polynomial and let $(m_1,\ldots,m_n) \subset \Z_{\ge 0}^n$.
The partial derivative with index $(m_1,\ldots,m_n)$ is defined as follows.
$$
\partial f^{(m_1,\ldots,m_n)} =
\dfrac{\partial^{m_1} f}{\partial x_1} \cdots \dfrac{\partial^{m_n} f}{\partial x_n}.
$$
:::

::: {.definition #pdo-matrix}
[@gv1995, Definition 2]

Let $\mathbf{h} = (h_1,\ldots,h_k) \subset \Z[x_1,\ldots,x_n]$, $\mathbf{i} = (i_1,\ldots,i_k) \subset \{1,\ldots,n\}^k$, $j \in \{1,\ldots,n\}$ and $f \in \Z[x_1,\ldots,x_n]$.
We define the partial differential operator $\partial_{\mathbf{h}, \mathbf{i}, j} f$ as the determinant
$$
\det\begin{pmatrix}\dfrac{\partial h_{1}}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial h_{1}}{\partial x_{i_{k}}} & \dfrac{\partial h_{1}}{\partial x_{j}}\\
 & \vdots\\
\dfrac{\partial h_{k}}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial h_{k}}{\partial x_{i_{k}}} & \dfrac{\partial h_{k}}{\partial x_{j}}\\
\dfrac{\partial f}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial f}{\partial x_{i_{k}}} & \dfrac{\partial f}{\partial x_{j}}
\end{pmatrix}
$$
and write $\partial^m_{\mathbf{h}, \mathbf{i}, j}$ to mean the $m$-th iteration of $\partial_{\mathbf{h}, \mathbf{i}, j}$.
:::

We can now present the algorithm from @gv1995, Theorem 2.

::: {.theorem #strat }
Let
$$
X := \{ \mathbf{x} \in \R^n \mid f_1 = 0, \ldots, f_q = 0, g_1 > 0, \ldots, g_r > 0 \},
$$
be a semialgebraic set defined by $s := q + r$ different polynomials of maximum degree $d$.
Then there is an algorithm, without oracle, which partitions $X$ into a family
$$
{\cal X} = (X_0, \ldots, X_n)
$$
such that, if $X$ is nonsingular, $X_0 = X$ and all other sets are empty.
Otherwise, $X_0 = \emptyset$ and each $X_k, 1 \le k \le n$ is a possibly empty, effectively nonsingular stratum of codimension $k$.
This algorithm has complexity
$$
3^{s}\left(s(d+1)\right)^{\O(n)^{2}}.
$$
The number of strata does not exceed $s^{n} (d + 1)^2$, and each stratum is defined by at most $s (d + 1)^2$ polynomial equations and inequalities of maximum degree $(d + 1)^2$.
:::

::: {.algorithm data-latex="Smooth Stratification"}
$${\cal X} := \textproc{Stratify}(k, F, \mathbf{h}, \mathbf{i}, G)$$

**Input:**

  - $0 \le k \le n$
  - $F = (f_1,\ldots,f_q)$, with each $f_i \in \Z[x_1,\ldots,x_n]$ for $1 \le i \le q$, is a list of polynomials,
  - $\mathbf{h} = (h_k, \ldots,h_1, h_0)$, with each $h_i \in \Z[x_1,\ldots,x_n]$ for $1 \le i \le k$, and $h_0 = 0$,
  - $\mathbf{i} = (i_k, \ldots, i_1,i_0)$ with each $i_j \in \Z_{\ge 0}, 1 \le j \le k$ and $i_0 = 0$,
  - $G = \{g_1,\ldots,g_r\} \subset \Z[x_1,\ldots,x_n]$.

**Output:**
$$
{\cal X} = (X_{k+1}, \ldots, X_n)
$$
$X_i, k+1 \le i \le n$ is a possibly empty, effectively nonsingular stratum of codimension $i$.
Note that the output ${\cal X}_{n+1} = ()$.

\begin{algorithmic}[1]
\Procedure{Stratify}{$k, F, \mathbf{h}, \mathbf{i}, G$}
\If{$i_k = n$} \Comment{base case}
    \State \Return ${\cal X}_{k+1} = (\emptyset, \ldots, \emptyset)$
\Else
    \State \Comment{initialise: polynomials and indices, strata of codimension $k+1$}
    \State $Z \gets \{ \mathbf{x} \in \R^n \mid g_1(\mathbf{x}) > 0, \ldots, g_r(\mathbf{x}) > 0 \}$
    \State $X' \gets X = \{ f_1 = 0,\ldots,f_q = 0 \} \cap Z$,
    \State ${\cal F} \gets \{ ((0,\ldots,0,1), f_1), \ldots, ((0,\ldots,0,q), f_q) \}$
    \State $X_{k+1} \gets \emptyset$
    \State $\mathbf{m} = (i_n,\ldots,i_{k+1},j) \gets (0,\ldots,0,1,1) \in \Z_{\ge 0}^{n-k+1}$
    \State $M = (\max\deg_n(f_1, \ldots, f_q), \ldots, \max\deg_{k+1}(f_1, \ldots, f_q))$
    \State \Comment{where $\max\deg_j(f_1,\ldots,f_q) = \max(\deg_j(f_1),\ldots,\deg_j(f_q))$}

    \State $\mathbf{h}' = (h_1,\ldots,h_k), \mathbf{i}' \gets (i_1,\ldots,i_k)$
    \While {$\mathbf{m} \prec M$}
        \State $(0,\ldots,0,i_\ell,\ldots,i_{k+1},j) = \mathbf{m}$
        \State $\mathbf{j} \gets (0, \ldots, 0, i_{\ell} - 1, i_{\ell - 1}, \ldots, i_{k+1},j).$
        \State $h_{k+1} \gets \partial_{\mathbf{h}',\mathbf{i}',i_\ell}^{i_{\ell} - 1} \partial_{\mathbf{h}',\mathbf{i}',i_\ell - 1}^{i_{\ell - 1}} \ldots\partial_{\mathbf{h}',\mathbf{i}',i_{k}+1}^{i_{k}+1}f_{j}$
        \State \Comment{where $f_j$ is the polynomial in $\cal F$ with index $(0,\ldots,0,j)$}
        \State \Comment {$h_{k+1}$ is a polynomial in $\cal F$ -- it can be foundd by index.}
        \State Compute $s_{k+1} \gets \partial_{\mathbf{h}',\mathbf{i}', i_\ell} h_{k+1}.$
        \State \Comment{define the sets $Y_{k+1}$ and $U_{k+1}$ as follows:}
        \State $Y_{k+1} \gets \{ \mathbf{x} \in X' \mid s_{k+1}(\mathbf{x}) \ne 0 \}$
        \State $U_{k+1} \gets \{ \mathbf{x} \in \R^n \mid h_{k+1}(\mathbf{x}) = 0, s_{k+1}(\mathbf{x}) \ne 0 \} \cap Z$

        \If {$\textproc{OpenSubset}(Y_{k+1}, U_{k+1})$}
            \State $X_{k+1} \gets X_{k+1} \cup \{ Y_{k+1} \}$
            \Comment{smooth and has codimension $k+1$}
        \Else \Comment{candidate is not smooth -- proceed by induction}
            \State $\mathcal{X}' \gets \textproc{Stratify}(k+1, F, (h_{k+1},h_{k},\ldots,h_0), (i_\ell,i_{k},\ldots,i_0), G)$
            \State \Comment{where $\mathcal{X}'= (X^{\mathbf{m}}_{k+2},\ldots,X^{\mathbf{m}}_n)$}
        \EndIf
        \State \Comment{check if we are done, or proceed to the next index}
        \If {$\textproc{Empty}(X',s_{k+1})$} \Comment{no more candidate strata}
            \State \Return ${\cal X}_{k+1} = (X_{k+1}, X_{k+2}, \ldots, X_n)$
            \State \Comment{each $X_i, k+2\le i \le n$ is the union of all strata $X^{\mathbf{m}}_i$}
        \Else \Comment{proceed to the next lexicographical index}
            \State $X' \gets \{ \mathbf{x} \in \R^n \mid s(\mathbf{x}) = 0 \}$,
            \State ${\cal F} := {\cal F} \cup \{ ((0,\ldots,0,i_\ell,\ldots,i_{k+1},j), s_{k+1}) \}$,
            \State $F := F \cup [s_{k+1}]$ \Comment{append $s_{k+1}$ to the end of the list $F$}
            \State $\mathbf{m} \gets \textproc{NextIndex}(\mathbf{m})$.
        \EndIf
    \EndWhile
\EndIf
\EndProcedure
\end{algorithmic}
:::

To call this algorithm on a semialgebraic set $X \subset \R^n$ defined by equations $F \subset \Z[x_1,\ldots,x_n]$ and $G \subset \Z[x_1,\ldots,z_n]$, compute
$$
{\cal X}' = \textproc{Stratify}(0, F, (0), (0), G)
$$
to obtain a set of strata ${\cal X'} = (X_1, \ldots, X_n)$.
If all $X_i = \emptyset, 1 \le i \le n$, then we can conclude that every partial derivative vanishes identically on the input set $X$.
Hence, $X$ is a smooth stratum in $\R^n$ and we set $X_0 = X$.
Otherwise, let $X_0 = \emptyset$ so that ${\cal X} = (\emptyset, X_1,\ldots,X_n)$ where each $X_i,1\le i \le n$ is a smooth subset of $X$ of codimension $i$, such that each $X_i,X_j,i\ne j$ is pairwise disjoint and $X_1\cup \ldots \cup X_n = X$.
Note, in the case that $X_0 = X$, the smooth stratification algorithm provides no information about the dimension of $X$.

### Subroutines and further details { #sec:strat-algorithm-details }

The algorithm employs two subroutines, which appear in the description as "black-box functions".

The first of these, $\textproc{OpenSubset}$, is a subroutine which determines whether $Y_k$ is an open subset of $U_k$.
This is the case if, for every point $\mathbf{x}$ in $Y_k$ all points of $U_k$ which are sufficiently close to $\mathbf{x}$ are also in $Y_k$.
This can be expressed as a first-order Boolean formula with two quantifier alternations and its truth value can be determined by performing quantifier elimination. I.e., $Y_k$ is an open subset of $U_k$ if
$$
\forall \mathbf{x} \in Y_k \> \exists \varepsilon > 0 \in \R \> \forall \mathbf{y} \in U_k \mid \Vert \mathbf{x} - \mathbf{y} \Vert < \varepsilon \rightarrow \mathbf{y} \in Y_k.
$$
An alternative method, as described in @gv1995, Theorem 2, is to check whether every derivative computed at step $k+1$ vanishes on the set
$$
U_k \cap \{ x_1 = \tt{const} \mid i < i_1 \}
$$
where $i_k \in \{1,\ldots,n\}$ is a parameter passed from step $k$ to $k+1$ in the algorithm.
This, again, reduces to the emptiness check.

The second of these subroutines is $\textproc{Empty}(S)$, where $S \subset \R^n$ is a semialgebraic set represented by a
quantifier-free Boolean formula which is a conjunction of polynomial equations, inequations and inequalities. Note that
an inequation $\{ f(\mathbf{x}) \ne 0 \}$ can be rewritten as $\{ f(\mathbf{x}) < 0 \lor f(\mathbf{x}) > 0 \}$, so it is
possible to represent $S$ by two systems of polynomial equations and inequalities, or a Boolean formula containing the
conjunction above. This permits various methods for checking emptiness. We may write $\textproc{Empty}(S)$ as a quantifier elimination problem:
\begin{align*}
\exists \mathbf{x} \in \R^n \mid\ & f_1(\mathbf{x}) = \ldots = f_s(\mathbf{x}) = 0,\\
& s_1(\mathbf{x}) \ne 0, \ldots, s_k(\mathbf{x}) \ne 0,\\
& g_1(\mathbf{x}) > 0, \ldots, g_t(\mathbf{x}) > 0.
\end{align*}
This problem can be decided using the singly-exponential quantifier elimination algorithm from Proposition
\@ref(prp:bpr-qe) (@bpr2006, Algorithm 14.21), which, with one quantifier alternation, has complexity $(sd)^{\O(n)}$
where $s$ is the number of different polynomials defining the set and $d$ their maximum degree -- singly exponential in
the number of variables. Alternatively, the algorithm presented by @bpr98, which produces a witness point in every cell
in a decomposition of the input set, may be used to decide emptiness. This algorithm also has complexity $(sd)^{\O(n)}$.
Unfortunately, both of these algorithms are theoretical and have not been implemented.
Therefore, in practice, quantifier elimination can be performed using CAD. This, of course, has complexity doubly exponential in
the number of variables: $(sd)^{\O(1)^n}$ (see Proposition \@ref(prp:collins)).

The algorithm may be implemented as above, but with some small tweaks to simplify the code and make the algorithm work slightly more efficiently.
First, observe that not all derivatives are needed to define the candidate stratum $Y_k$. One obvious situation is when a derivative $s_k$ turns out to be a nonzero constant $c \in \A$.
In the formula for $Y_k$, the inequation $c \ne 0$ will appear, which is obviously true. Since $X' \supset Y_k$ was assumed to be non-empty, we can immediately conclude that $Y_k$ is non-empty and equal to $X'$. No further derivatives at step $k$ need to be considered, since $X' \setminus Y_1 = \emptyset$.
A similar situation may arise, even with nonconstant functions $s_k$. For example, for the input set
$$
X := \{ \mathbf{x} \in \R^2 \mid x^2 y^2 = 0 \},
$$
the derivative for index $(0,1)$ is $\partial (x^2 y^2) / \partial x_1 = 2x y^2$, which is equal to zero at every point of $X$.
By discarding these redundant functions, we minimise the number of polynomials defining sets in the emptiness check. Note that we have to keep track of every derivative computed, even the redundant ones, so that we can find the function $h_k$ such that $s_k = \partial_{\mathbf{h}, \mathbf{i}, j} h_1$.

Now consider, given an index $(0,\ldots,0,i_\ell,i_{\ell - 1},\ldots,i_{k+1},j)$, the operation of finding the derivative with index $(0,\ldots,0,i_\ell - 1,i_{\ell - 1}, \ldots, i_{k+1},j)$. The following observation allows us to quickly find this polynomial, avoiding a search in $\cal G$ or unnecesary recomputation of derivatives.
Suppose we are considering index
$$
\mathbf{m} = (0,\ldots,0,i_\ell,i_{\ell - 1},\ldots,i_{k+1},j)$$
and want to find the derivative with index
$$
\mathbf{j} = (0,\ldots,0,i_\ell - 1,i_{\ell - 1},\ldots,i_{k+1},j).$$
The set $\cal G$ includes polynomials computed in previous rounds of induction and those with index $\mathbf{i} \prec \mathbf{m}$, since we proceed in ascending lexicographical order. Hence $\cal G$ contains the derivative with index $\mathbf{j}$.
There is a convenient way to find this derivative.
Let us first illustrate the process with an example. Let $f_j \in \Z[x_1,x_2,x_3]$ with $M_j = (1,2,2)$ and consider the lexicographically ordered list of indices
\begin{align*}
L_1 :=\ &(0,0,1),(0,0,2),(0,1,0),(0,1,1),(0,1,2),(1,0,0),(1,0,1),\ldots\\
L_2 :=\ &(0,0,0),(0,0,1),(0,0,0),(0,0,1),(0,0,2),(0,0,0),(0,0,1),\ldots
\end{align*}
Observe that for indices of the kind $(0,\ldots,0,1,0,\ldots,0)$ in $L_1$, the corresponding element of $L_2$ is $(0,\ldots,0)$. For an arbitrary index $(0,\ldots,0,i_\ell,\ldots,i_1)$ in $L_1$ which appears $k$ elements after $(0,\ldots,0,i_\ell = 1,0,\ldots,0)$, the corresponding element in $L_2$ appears $k$ elements after $(0,\ldots,0)$.
From this, we can introduce an "index chasing" method as follows. Let ${\cal G}_j$ be the (ordered) list of derivatives of polynomial $f_j$. For each $\mathbf{m}$, we keep a pointer, ${\cal G}'_j$, to the element in ${\cal G}_j$ with index $\mathbf{j}$.

- Initialise ${\cal G}_j = ((0,\ldots,0),f_j)$. For $\mathbf{m} = (0,\ldots,0,1)$, set ${\cal G}'_j = {\cal G}_j$.
- Now suppose that ${\cal G}_j$ contains all polynomials with index $\prec \mathbf{m}$.
  - If $\mathbf{m} = (0,\ldots,0,1,0,\ldots,0)$, then $\mathbf{j} = (0,\ldots,0)$ and we set ${\cal G}'_j$ to the head of ${\cal G}_j$.
  - Otherwise, let ${\cal G}'_j$ be the tail of ${\cal G}'_j$.

The "index chasing" method works efficiently in `SACLIB`, which uses linked lists. However, we do need to append new
derivatives to the end of ${\cal G}_j$, which takes $\O(n)$ steps.
To avoid this, we keep a pointer to the last-but-one element in the list, i.e., suppose $G_j = (a_1,(\ldots,(a_{r-1},(a_r,(\mathrm{NIL})))\ldots)$ then $G_{j,\rm{append}} = (a_{r-1},(a_r,(\mathrm{NIL})))$. Then, if we wish to append $b$ to the end of $G_j$, we simply need to set the tail of $G_{j,\rm{append}}$ to $(a_r,(b,(\mathrm{NIL})))$.

We can also optimise the construction of the matrix associated to the partial differential operator $\partial_{\mathbf{h},\mathbf{i},j} f$. In this matrix,
$$
\begin{pmatrix}\dfrac{\partial h_{1}}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial h_{1}}{\partial x_{i_{k}}} & \dfrac{\partial h_{1}}{\partial x_{j}}\\
 & \vdots\\
\dfrac{\partial h_{k}}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial h_{k}}{\partial x_{i_{k}}} & \dfrac{\partial h_{k}}{\partial x_{j}}\\
\dfrac{\partial f}{\partial x_{i_{1}}} & \cdots & \dfrac{\partial f}{\partial x_{i_{k}}} & \dfrac{\partial f}{\partial x_{j}}
\end{pmatrix},
$$
only the last row depends on $f$ and only the last column depends on $j$. Thus, we can save the $(k\times k)$-submatrix
consisting of the first $k$ rows and columns and only append the new row and column. This matrix can be passed as an
argument to $\textproc{Stratify}(k,\ldots)$, with the matrix for $k=0$ being empty (i.e., $\mathbf{h} = \mathbf{i} = ()$ in the partial differential operator).

## Worked example { #sec:strat-worked-example }

We illustrate the smooth stratification algorithm with a worked example in $\R^3$. Consider
$$
\{ z = 0, x^2-y^2=0 \} \subset \R^3.
$$
This set is contained in the plane $\{ z = 0 \}$ and consists of the two intersecting straight lines $\{ x - y = 0 \}$
and $\{ x + y = 0 \}$ in $\opspan{x,y}$.
The algorithm imposes an order on polynomials. Here we take $f_1 := z$ and $f_2 = x^2 - y^2$.
The algorithm proceeds as follows:

- Begin by calling $\textproc{Stratify}(0, \{ f_1 := z, f_2 := x^2 - y^2 \}, (0), (0), \emptyset)$.

    - Lines 6-11 initialise
    \begin{align*}
Z &:= \R^3,\\
X' &:= \{ z = 0, x^2 - y^2 = 0 \},\\
\mathcal{F} &:= \{ ((0,0,0,1), f_1 := z), ((0,0,0,2), f_2 := x^2 - y^2) \},\\
X_1 &:= \emptyset,\\
\mathbf{m} &:= (0,0,1,1),
M &:= (1,2,2,2).
\end{align*}
    - Line 12 onwards iterates over indices in lexicographical order.
    - The initial index is $\mathbf{m} = (0,0,1,1)$.
      - $\mathbf{j} = (0,0,0,1)$, so polynomial $h_1 := f_1 = z$, the polynomial in $\mathcal{F}$ with index $(0,0,0,1)$.
      - $s_1 := \partial_{(), (), x} h_1 = 0$ is computed.
      - This makes $Y_1 := \{ \mathbf{x} \in X' \mid 0 \ne 0 \} = \emptyset$.
      - Without reference to $U_1$, it's clear that the openness check (line 22) returns false.
      - The recursive call (line 25) can be skipped, since the input set would be empty.
      - The set $X' := \{ f_1 := z = 0, f_2 := x^2 - y^" = 0, s_1 := 0 = 0 \} = X'$ is non-empty, so we proceed to the next index with respect to lexicographical order: $\mathbf{m} = (0,0,1,2)$.
      - Usually, $s_1$ is added to $\mathcal{F}$ (with its index), and $F$ (without index), but since $s_1 = 0$, this operation will be skipped. In the implementation, even zero derivatives are added to $\mathcal{F}$ to ensure that the index chasing algorithm works correctly.
    - When $\mathbf{m} = (0,0,1,2)$, $\mathbf{j} = (0,0,0,2)$.
      - Polynomials $h_1 := f_2 = x^2 - y^2$ and $s_1 := \partial_{(), (), x} h_1 = 2x$.
      - Define the sets
\begin{align*}
Y_1 &:= \{ z = 0, x^2 - y^2 = 0, 2x \ne 0 \} = X \setminus \{ (0,0,0) \},\\
U_1 &:= \{ x^2 - y^2 = 0, 2x \ne 0 \}.
\end{align*}
      - The openness check on line 22 returns false, so we proceed by induction on $Y_1$, with $h_1 := x^2 - y^2$ and $i_1 := i$ (first variable).

      - Call $\textproc{Stratify}(1, \{ z, x^2 - y^2 \}, (x^2 - y^2,0), (1, 0), \{ 2x \ne 0 \})$.

        - Again, initialisation takes place.
\begin{align*}
Z &:= \{ 2x \ne 0 \},\\
X' &:= \{ z = 0, x^2 - y^2 = 0 \} \cap Z,\\
\mathcal{F} &:= \{ ((0,0,1), f_1 := z), ((0,0,2), f_2 := x^2 - y^2) \},\\
\mathbf{m} &:= (0,1,1),\\
X_2 &:= \emptyset.
\end{align*}
        - Work through indices in lexicographical order.
        - When $\mathbf{m} := (0,1,1)$, $\mathbf{j} := (0,0,1)$ so that $h_2 := f_1 = z$.
          - Compute $s_{2}:=\partial_{(x^{2}-y^{2})(x),y}(z) = 0$ -- since polynomial $z$ is independent of both $x$ and $y$, the last column of the matrix is $0$, so the determinant is $0$.
          - This results in $0 \ne 0$ in the definition of the set $Y_2$, so we proceed to the next index with respect to lexicographical order.
        - When $\mathbf{m} = (0,1,2)$, $\mathbf{j} = (0,0,2)$ so that $h_2 := f_2 = x^2 - y^2$.
          - Compute $s_{2}:=\partial_{(x^{2}-y^{2})(1),y}(x^{2}-y^{2}) = 0$ -- since both rows of the matrix are identical.
          - Proceed to the next lexicographical index.
        - When $\mathbf{m} = (1,0,1)$, $\mathbf{j} = (0,0,1)$ so that $h_2 := f_1 = z$.
          - Compute
\begin{align*}
s_{2}&:=\partial_{(x^{2}-y^{2})(x),z}(z)\\&=\det\begin{pmatrix}\partial(x^{2}-y^{2})\partial x & \partial(x^{2}-y^{2})/\partial z\\
\partial(z)/\partial x & \partial(z)/\partial z
\end{pmatrix}\\&=\det\begin{pmatrix}2x & 0\\
0 & 1
\end{pmatrix}\\&= 2x.
\end{align*}
          - Define the sets
\begin{align*}
Y_2 &:= \{ z = 0, x^2 - y^2 = 0, 2x \ne 0 \} = X \setminus \{ (0,0,0) \},\\
U_2 &:= \{ x^2 - y^2 = 0, z = 0, 2x \ne 0 \}.
\end{align*}
          - We have $Y_1 = Y_2 = U_2$.
          - The openness check returns true, therefore $Y_2$ is smooth and should be added to $X_2$.
          - The emptiness check on $\{ z = 0, x^2 - y^2 = 0, 2x \ne 0, 2x = 0 \}$ returns false, so there are no more candidate strata to consider and we return
          $$
          \mathcal{X}' := (X_2 = \{ \{ z = 0, x^2 - y^2 = 0, 2x \ne 0 \} \}, X_3 = \emptyset).
          $$

- Return to the calling function (line 25).

    - Recall that $\mathbf{m} = (0,0,1,2)$, $\mathbf{j} = (0,0,0,2)$ and $s_2 = 2x$.
      - Update $X' := \{ z = 0, x^2 - y^2 = 0, 2x = 0 \}$.
      - The emptiness check on $X'$ returns true, so we proceed to the next index and add $((0,0,1,2), s_1)$ to $\mathcal{F}$ and $s_1$ (without index) to $F$.
    - When $\mathbf{m} = (0,0,2,1)$, $\mathbf{j} = (0,0,1,1)$.
      - Since $h_1 := \partial_{(),(),x}(z) = 0$, $s_1 = 0$.
      - Proceed to the next index.
    - When $\mathbf{m} = (0,0,2,2)$, $\mathbf{j} = (0,0,1,2)$.
      - Polynomial $h_1 := \partial_{(),(),x}(x^2 - y^2) = 2x$.
      - Then $s_1 := \partial_{(),(),x} (2x) = 2$.
      - Define the sets
\begin{align*}
Y_1 &:= \{ z = 0, x^2 - y^2 = 0, 2x \ne 0, 2 \ne 0 \} = (0,0,0),\\
U_1 &:= \{ 2x = 0, 2 \ne 0 \}.
\end{align*}
      - $Y_1$ (a point) is not open in $U_1$ (a plane), so we proceed by induction.

      - Call $\textproc{Stratify}(1, \{ z, x^2 - y^2, 2x \}, (2x,0), (1, 0), \emptyset)$.

        - Initialise
\begin{align*}
X' &:= \{ z = 0, x^2 - y^2 = 0, 2x = 0\} = (0,0,0),\\
\mathcal{F} &:= \{ ((0,0,1), f_1 := z), ((0,0,2), f_2 := x^2 - y^2), ((0,0,3), 2x) \},\\
\mathbf{m} &:= (0,1,1),\\
X_2 &:= \emptyset.
\end{align*}
        - Work through indices in ascending lexicographical order.
        - When $\mathbf{m} = (0,1,1)$, $\mathbf{j} = (0,0,1)$ and $h_2 := z$.
          - As before, since $z$ is independent of both $x$ and $y$, we get $s_2 = 0$, so we proceed to the next index.
        - When $\mathbf{m} = (0,1,2)$, $\mathbf{j} = (0,0,2)$ and $h_2 := x^2 - y^2$.
          - Compute
\begin{align*}
s_{2}&:=\partial_{(2x)(x),y}(x^{2}-y^{2})\\&=\det\begin{pmatrix}\partial(x^{2}-y^{2})\partial x & \partial(x^{2}-y^{2})/\partial z\\
\partial(2x)/\partial x & \partial(2x)/\partial z
\end{pmatrix}\\&=\det\begin{pmatrix}2x & 2y\\
2 & 0
\end{pmatrix}\\&=-4x.
\end{align*}
          - Since $4x \ne 0$ contradicts $2x = 0$, the set $Y_2$ is empty.
          - Do not proceed by induction, since $Y_1$ is an empty set. Instead, proceed to the next lexicographical index.
        - When $\mathbf{m} = (0,1,3)$, $\mathbf{j} = (0,0,3)$ and $h_2 := 2x$.
          - As before, since $2x$ is independent of $y$, we get $s_2 = 0$, so we proceed to the next index.
        - When $\mathbf{m} = (1,0,1)$, $\mathbf{j} = (0,0,1)$ and $h_2 := z$.
          - Compute
\begin{align*}
s_{2}&:=\partial_{(2x)(x),z}(z)\\&=\det\begin{pmatrix}\partial(2x)\partial x & \partial(2x)/\partial z\\
\partial(z)/\partial x & \partial(z)/\partial z
\end{pmatrix}\\&=\det\begin{pmatrix}2 & 0\\
0 & 1
\end{pmatrix}\\&=2.
\end{align*}
          - Define the sets
\begin{align*}
Y_2 = Y_1 &:= (0,0,0),\\
U_2 &:= \{ 2x = 0, z = 0, 2 \ne 0 \}.
\end{align*}
          - Since $Y_2$ (a point) is not open in $U_2$ (a plane), we proceed by induction.
          - However, since $i_2 = 3$, no more partial derivatives can be computed. No strata have been added. Return
          $$
          \mathcal{X}' := (X_2 = \emptyset, X_3 = \emptyset).
          $$

- Return to the calling function with $k=0$ (line 25).

  - We conclude that $Y_1$ must have codimension $3$. Append it to $X_3$.

As expected, the algorithm outputs the set of strata
\begin{align*}
\mathcal{X}_{1}:=&\emptyset\\\mathcal{X}_{2}:=&\left\{ x^{2} - y^{2}=0,z=0,2x\ne0\right\} \\\mathcal{X}_{3}:=&\left\{ (0,0,0)\right\}
\end{align*}

## Optimising the output

### Codimension and basic formula { #sec:strat-basic-formula }

@gv1995, Theorem 2 asserts that each stratum of codimension $k$ can be represented by a conjunction containing at least $k$
equations and, possibly, some inequalities. The condition that each stratum can be written as a conjunction means that
it is a basic semi-Pfaffian set (see Definition \@ref(def:semi-pfaff))
A naive implementation of the procedure can lead to an inefficient representation of strata, as
shown in the following example:

::: {.example}
Consider the semialgebraic set
$$
S := \{ (x,y) \in \R^2 \mid x y = 0 \}.
$$
Apply the algorithm.
\begin{align*}
k=0,X':=&\left\{ \mathbf{x}\in\mathbb{R}^{2}\mid f_{1}:=x y=0\right\} \\\left(0,1,1\right)h_{1}=&f_{1}=x
y\\s_{1}=\partial f_{1}/\partial x =&y\\Y_{1}:=&\left\{ \mathbf{x}\in X'\mid y\ne0\right\} \\U_{1}:=&\left\{
\mathbf{x}\in \mathbb{R}^2\mid x y=0,y\ne0\right\} \\&\text{Proceed by induction}\\
k=1,h_{1}=f_{1},i_{1}=1,X'':=&Y_{1},F_{1}=\left\{ f_{1}\right\}
\\\left(1,1\right),h_{2}=&f_{1}\\s_{2}=&\begin{pmatrix}\partial f_{1}/\partial x & \partial f_{1}/\partial y\\
\partial f_{2}/\partial x & \partial f_{1}/\partial y
\end{pmatrix}=0\\&\text{since both columns are equal.}\\\text{Return. }Y_{1}&\text{ is smooth.}\\
\end{align*}

Observe that the formula for $Y_1$ contains one equation, $h_1 = f_1$. Hence $Y_1$ is a smooth stratum in basic representation and we can conclude that it has codimension $1$.

For the next nonzero derivative, with index $(1,0,1)$, we get
\begin{align*}
k=0,X':=&\left\{ \mathbf{x}\in\mathbb{R}^{2}\mid x y=0,y=0\right\} \\\left(1,0,1\right)\ h_{1}=&f_{1}=x
y\\s_{1}=\partial f_{1}/\partial x y=&x \\Y_{1}:=&\left\{ \mathbf{x}\in X'\mid x\ne0\right\} \\U_{1}:=&\left\{ \mathbf{x}\in\mathbb{R}^{2}\mid xx_{2}=0,x\ne0\right\} \\&\text{Proceed by indection.}\\k=1,h_{1}=f_{1},i_{1}=2,X'':=&Y_{1}\ldots\\&\text{No partial derivatives can be computed.}\\\text{Return. }Y_{1}&\text{ is smooth.}
\end{align*}

Notice that the inductive step returns immediately. This is because $i_1=2$, so it is not possible to take further partial derivatives with respect to $j > i_1$. In the formula for
$$
Y_1 := \{ \mathbf{x} \in \R^2 \mid f_1 := x y = 0, h_1 := y  = 0, x \ne 0 \},
$$
two different equations, $f_1$ and $h_1$ appear.
However, $Y_1$ is not represented in the most efficient way.
Indeed, the equation $f_1=0$ is redundant, since $f_1$ is equal to zero for all points at which $h_1$ is equal to zero. Thus $f_1$ can be discarded, and we see that only one equation, $h_1$, is required to represent $Y_1$ in basic form.
We can conclude that $Y_1$ is smooth and has codimension $1$.

Finally, consider the derivative with index $(1,1,1)$.
\begin{align*}
k=0,X':=&\left\{ \mathbf{x}\in\mathbb{R}^{2}\mid x y=0,y =0,x=0\right\} \\\left(1,1,1\right) h_{1}=&s_{1}^{\left(0,1,1\right)}=y\\s_{1}=\partial f_{1}/\partial y=&1\\Y_{1}:=&\left\{ \mathbf{x}\in X'\mid1\ne0\right\} \\U_{1}:=&\left\{ \mathbf{x}\in\mathbb{R}^{2}\mid y=0,1\ne0\right\}
\end{align*}
Again, the inductive step returns immediately because $i_1=2$, but this time we can see that $Y_1$ is not an open subset
of $U_1$. As mentioned above, the algorithm is unable to determine this without solving a quantifier elimination
problem. Instead, we may be able to determine the codimension by looking at the most eefficient representation of $$
Y_1 := \{ (x,y) \in \mathbb{R}^2 \mid x y = 0, x = 0, y = 0 \}.
$$
(Note that the constraint $1 \ne 0$ is dropped since it is trivial and adds no information.)
We see that three equations appear in the definition of $Y_1$, but the first one, $f_1 := x y_2$ is redundant again.
Thus, the two equations $y = 0, x = 0$ define $Y_1$ and we can conclude that $Y_1$ is smooth and has codimension $2$.
:::

This example illustrates two things. Firstly, not all functions are required to represent the smooth stratum and secondly, $k$, the current step of induction, gives only a lower bound on the codimension of strata.
@gv1995, Theorem 1 states that each stratum $Y \subset X_k$, if non-empty, is nonsingular and of codimension $k$. At each point $\mathbf{x} \in Y$,
$$
\det\begin{pmatrix}\partial h_{1}/\partial x_{i_{1}} & \ldots & \partial h_{1}/\partial x_{i_{k}}\\
\vdots &  & \vdots\\
\partial h_{k}/\partial x_{i_{1}} & \ldots & \partial h_{k}/\partial x_{i_{k}}
\end{pmatrix} \ne 0,
$$
where the functions $h_1,\ldots,h_k$ appear in the definition of $Y$.
The property that this determinant is not equal to zero at every point in $Y$ ensures that $Y$ is
effectively nonsingular and has codimension $k$ (see Definition \@ref(def:eff-non-sing)). I.e., in the neighbourhood of each point $\mathbf{x}\in Y$, $Y$ is the intersection of $k$ coordinate hyperplanes. In fact, these hyperplanes are the algebraic sets $\{h_j = 0\}$ for $1\le j \le k$ because $h_1,\ldots,h_k$ are chosen such that they are algebraically independent. Note that the set $\{ h_1 = 0,\ldots,h_k = 0 \}$ itself may be singular. It could even consist of several connected components having different dimensions. However, the property holds at every point in the input set $X$.
We now work to minimise the set of defining equations for each stratum $Y \subset X_k$, starting with the required polynomials $h_1,\ldots,h_k$.

### Discarding redundant equations

Let $F \subset \Z[x_1,\ldots,x_n]$ be a set of polynomials, indexed by $(m_{i_1},\ldots,m_1,j)$ and, for $\mathbf{m} = (0,\ldots,0,m_\ell,\ldots,m_1,j),\ell > i_1$ let
$$
s^{m_n,\ldots,m_1,j}_k = \partial_{\mathbf{h}, \mathbf{i}, n}^{m_n} \partial_{\mathbf{h}, \mathbf{i}, i_1 + 1}^{m_{i_1 + 1}} f
$$
be the partial derivative computed at index $\mathbf{m}$, where $f \in F$ has index $(m_1,\ldots,m_1,j)$ be one of the partial derivatives computed during the algorithm.
Denote by $G$ the set of derivatives with index lexicographically less than $\mathbf{m}$. $Y_k \subset Y_{k-1}$ is defined such that every function in $G$ is equal to zero while the function $h^{\mathbf{m}}_k$ is not.
Define the smooth manifold
\begin{align*}
U_k := \{ \mathbf{x} \in \R^n \mid &\ h_1(\mathbf{x}) = 0, \ldots, h_{k-1}(\mathbf{x}) = 0,\\
&\ h_k(\mathbf{x}) = 0, s^{\mathbf{m}}_k(\mathbf{x}) \ne 0 \}
\end{align*}
of codimension $k$, where the function $h_k := s^{(0,\ldots,0,m_\ell - 1,m_{\ell - 1},\ldots,m_1,j)}_k$. According to @gv1995, Theorem 2, $Y_k$ is smooth and has codimension $k$ if it is an open subset of $U_k$. In this case, only $k$ of the polynomials will be needed to define $Y_k$. Note that inequations $s_1,\ldots,s_{k-1}$ which appear in the definition of $Y_{k-1} \supset Y_k$ should also be taken into account.
Begin with a set
\begin{align*}
Y' := \{ \mathbf{x} \in \R^n \mid &\ h_1(\mathbf{x}) = 0, \ldots, h_{k-1}(\mathbf{x}) = 0,\\
&\ s_1(\mathbf{x}) \ne 0, \ldots, s_(\mathbf{x}) \ne 0, s_k(\mathbf{x}) \ne 0 \} \subset Y_k.
\end{align*}
Consider each function $g \in G$ in reverse lexicographical order. If $g(\mathbf{x}) = 0$ at every point $\mathbf{x} \in Y'$ then it is redundant and should be discarded. Otherwise, $g$ should be included in the defining equations for $Y_k$. Since $Y_k$ has codimension $k$, and $Y'$ is already an open, basic set of codimension $k-1$, only one more polynomial should be needed.
If $Y_k$ is not an open subset of $U_k$, then more polynomials will be required to define it, and the number of polynomials gives the codimension.

A polynomial $g \in \Z[x_1,\ldots,x_n]$ is redundant in the definition of the semialgebraic set $S \subset \R^n$ if the following formula is true
$$
\exists x_1,\ldots,x_n,a \in \R^{n+1} \mid (x_1,\ldots,x_n) \in S, a \ne 0, g(x_1,\ldots,x_n) = a.
$$
This problem can also be formulated using the emptiness check. $g$ is redundant in the definition of $S$ if the semialgebraic set
$$
\{ \mathbf{x} \in S \mid g(\mathbf{x}) \ne 0 \}
$$
is non-empty.

<!-- TODO do we also need to check that the determinant of the matrix (minors?) is nonzero. -->

### The semialgebraic case {#sec:strat-semialgebraic}

@gv1995, Corollary 1 asserts that the algorithm can be applied to arbitrary semi-Pfaffian sets and, therefore, without modification, to arbitrary semialgebraic sets.
Let $S \subset \R^n$ be a semialgebraic set represented by a quantifier-free Boolean formula containing polynomials
$f_1,\ldots,f_s.$
Consider each "sign set"
$$
S_{( \ast_1,\ldots,\ast_s )} := \{ \mathbf{x} \in \R^n \mid f_1(\mathbf{x}) \ast_1 0, \ldots, f_s(\mathbf{x}) \ast_s 0 \}
$$
where each $\ast_i \in \{<, >, =\}$ for $1 \le i \le s$. Observe that there are $s^3$ sign sets.
The set $S$ can be partitioned into a finite union of some of the sign sets.
If we apply the smooth stratification algorithm to each $S_{(\ast_1,\ldots,\ast_s)} \subset S$, and take the union of strata, we will obtain a smooth stratification of the set $S$. Indeed, since no two sign sets have non-empty intersection, it is clear that no two strata intersect, and since a finite number of the sign-sets form a partition of $S$, the smooth strata of these sign-sets also forms a partition of $S$.

### Implementation with SACLIB

Full source code is available on Zenodo at the following link:
[https://zenodo.org/records/14944918?token=eyJhbGciOiJIUzUxMiJ9.eyJpZCI6IjU1ZjgxYmVhLWJkYTEtNDM5MS04OTIxLWM4ZDYyYzA4YzUyNSIsImRhdGEiOnt9LCJyYW5kb20iOiJlYzk0NTA3YjUwYTM5MDhlOTZiYzcyNDFlYjIxZGFlOCJ9.TGZ59ufWzjdWGGnpsvZJm4Hy340ke3rzYAg2utBShywKaQn62XXS-gTpZrCJinKSXSYG81PwgV42VE3s0cfqKg](https://zenodo.org/records/14944918?token=eyJhbGciOiJIUzUxMiJ9.eyJpZCI6IjU1ZjgxYmVhLWJkYTEtNDM5MS04OTIxLWM4ZDYyYzA4YzUyNSIsImRhdGEiOnt9LCJyYW5kb20iOiJlYzk0NTA3YjUwYTM5MDhlOTZiYzcyNDFlYjIxZGFlOCJ9.TGZ59ufWzjdWGGnpsvZJm4Hy340ke3rzYAg2utBShywKaQn62XXS-gTpZrCJinKSXSYG81PwgV42VE3s0cfqKg).

This algorithm has been implemented in C, using the computer algebra library `SACLIB`. `QEPCAD-B` is used to perform emptiness checks using cylindrical algebraic decomposition. Below is an example of the new program's output, given the basic semialgebraic set
$$
\{ z = 0, x^2 - y^2 = 0 \} \subset \R^3,
$$
discussed in Section \@ref(sec:strat-worked-example).

```
Enter a variable list.
Please enter a QEPCAD formula defining a basic semialgebraic set.
(x,y,z)
[ z = 0 /\ x^2 - y^2 = 0 ].

Stratification computed. Please select an option.
  1. print all polynomials
  2. print all strata
  0. exit

1
All polynomials generated by the smooth stratification algorithm:
2 x
-y^2 + x^2
z
1
2 x
z
-y^2 + x^2

Stratification computed. Please select an option.
  1. print all polynomials
  2. print all strata
  0. exit
2
List of all strata.
Strata of codimension 1

Strata of codimension 2
X_(2,1):
  { z == 0
  , -y^2 + x^2 == 0
  , 2 x /= 0
  , 2 x /= 0
  }

Strata of codimension 3
X_(3,1):
  { -y^2 + x^2 == 0
  , z == 0
  , 2 x == 0
  }

```

The program works in a similar way to `QEPCAD-B` (see Section \@ref(sec:qepcad)), taking as input the variable list
(which specifies the order) and a conjunction of polynomial equations, inequations and inequalities (written as a
`QEPCAD-B` "prenex" formula). The stratification is then computed and there is a basic read execute print loop which allows the user to see information about the polynomials and strata produced.

Exerpts of the code are now presented and discussed. The entrypoint for the algorithm is `stratify`.

**Input:**

- `Word r` $\in \Z$ (ambient dimension),
- `Word L` $= \{f_1,\ldots,f_q\} \subset \Z[x_1,\ldots,x_r]$,
- `Word Ineqs` $= \{g_1,\ldots,g_r\} \subset \Z[x_1,\ldots,x_r]$,
- `Word V` $= (x_1,\ldots,x_r)$ is a variable list,

These parameters define $X = \{ f_1 = 0, \ldots, f_q = 0, g_1 > 0, \ldots, g_r = 0 \}$, the basic semialgebraic set to be stratified.

**Output:**

- `Word S`: set of smooth strata $(\mathcal{X}_1,\ldots,\mathcal{X}_r)$, such that $\mathcal{X}_i$ contains strata (semialgebraic sets defined by a conjunction of polynomial equations and inequalities) of codimension $i$ for $1 \le i \le r$, or `NIL` if $X$ is a smooth subset.

``` {c, code-strat-main, eval=FALSE, attr.source='.numberLines' }
Word stratify(Word r, Word L, Word Ineqs, Word V, Word *S_)
{
    // initialise strata S
    *S_ = NIL;
    int i = 0;
    while (i < r) {
        *S_ = COMP(NIL, *S_);
        ++i;
    }

    // initialise the inequalities as a QEPCAD formula
    Word D, P;
    Word F = NIL;
    while (Ineqs != NIL) {
        ADV(Ineqs, &P, &Ineqs);

        F = COMP(LIST4(GTOP, P, r, NIL), F);
    }

    // initialise the input set of polynomials with their degrees
    Word Fs = NIL, s = 0;
    while (L != NIL) {
        ADV(L, &P, &L);
        ++s;

        D = DEG(r, P);
        Fs = COMP(LIST2(P, D), Fs);
    }

    // ensure polynomials are processed in the correct order
    Fs = INV(Fs);

    // initial i0 = FIRST(I1) = 0. h0 = FIRST(Hs) = 0, Minor is the empty matrix
    int strata_appended;
    Word Gs = strat_helper(r, V, F, 1, s, Fs, LIST1(0), LIST1(0), NIL, NIL, &strata_appended, S_);

    if (strata_appended == 0) {
        // X is smooth
        *S_ = NIL;
    }

    return Gs;
}
```

The function `stratify` sets up the data structures required by a recursive helper function which performs stratification of some input set $X \subset \R^n$. The helper function, named `strat_helper`, is now described.

**Input:**

- `Word r` $\in \N$,
- `Word V`: variable list,
- `Word Ineqs`: `QEPCAD-B` prenex formula of inequalities $\{ g_1 > 0, \ldots, g_r >0 \}$,
- `Word k` $1\le k \le r$ is the codimension currently being worked with,
- `Word np`: $= q$ number of polynomials,
- `Word Fs` $((f_1,\deg(f_1)), \ldots, (f_{q}, \deg(f_{q})))$ is the list of input polynomials,
- `Word Is` is a partial index $(0,,i_1,\ldots,i_{k-1})$,
- `Word Hs` is the set of polynomials $(h_{i_1},\ldots,h_{i_{k-1}})$,
- `Word Qs` is a list of polynomials $\subset \Z[x_1,\ldots,x_n]$,
- `Word Minor` is a $((k-1)\times (k-1))$-matrix $A = \vert a_{ij} \vert = \partial h_{i} / \partial x_{j}$ for $h_i \in \rm{Hs}, j \in \rm{Is}$.

Here the input set $X$ is defined by equations `Fs` and `Hs`, inequalities `Ineqs` and inequations `Qs`.

**Output:**

- `Word Gs` $\subset \Z[x_1,\ldots,x_r]$ is the set of all partial differentials (for steps $k \le j \le r$),
- `int strat_count_` is the number of strata appended (for steps $k \le j \le r$),
- `Word S` is the set of strata (for steps $k \le j \le r$).

``` {c, code-strat-helper, eval=FALSE, attr.source='.numberLines' }
Word strat_helper(Word r, Word V, Word Ineqs, Word k, Word np, Word Fs, Word Is, Word Hs, Word Qs, Word Minor, int *strat_count_, Word *S_)
{
    // add constraints x_1 = 0, ..., x_{i1 - 1}  0
    Word i0 = FIRST(Is); // number of variables considered so far

    // base case for no polynomials?
    if (np == 0 || i0 >= r) {
        *strat_count_ = 0;
        return NIL;
    }

    // list of H polynomials (rev order) without the last (zero) one.
    Word Hs1 = RED(CINV(Hs));

    // set up return value
    Word Gs1 = NIL; // list of all differentials computed in this round, to return
    Word Gs2 = NIL; // list of differentials produced during induction
    Word Gs3 = NIL; // store Gs on current round

    // set up working array
    Word g_count = np; // how many differentials computed so far, index in Gs
    Word Gs = NIL; // list of all differentials computed in this round, working set

    // metadata
    Word Ms[np]; // number of steps before maximum differentiation variable (i1) should be incremented
    Word Dvs[np]; // list of current differentiation variable (i1)
    Word Backup[np]; // first polynomial in the list
    Word Chase[np]; // first element is h1
    Word ChaseIndex[np]; // chase array index of polynomial h1
    Word Append[np]; // pointer to last but one element in list, for quick appending.

    Word p_index = 0; // initial polynomial index, ranges over 0 <= p_index < np

    // initialise metadata for each input polynomial
    while (p_index < np) {
        Word F1;
        ADV(Fs, &F1, &Fs);

        Word D = REDI(SECOND(F1), i0);
        Ms[p_index] = COMP(1, LCOPY(D)); // need a copy as we modify later
        Dvs[p_index] = i0;
        Backup[p_index] = F1;
        Chase[p_index] = F1;
        ChaseIndex[p_index] = 0;
        Append[p_index] = RED(F1);
        Gs = COMP(LCOPY(F1), Gs);
        Gs3 = COMP(FIRST(F1), Gs3);

        // increment index
        ++p_index;
    }

    // main loop, consider each index (j, m_{i0 + 1}, ..., m_r) in lex order
    Word n_finished = 0; // each polynomial has a different max index, keep track of how many indices are maxed out
    Word count = 0; // number of derivatives computed so far, scalar value of (m_{i0 + 1}, ..., m_r)

    int strat_count = 0;
    while (n_finished < np) { // stop once differential index for every polynomial is maxed
        // reached the end of polynomial list, cycle back to beginning and consider next differential index I
        if (p_index == np) {
            p_index = 0;
            n_finished = 0;

            ++count;
        }

        Word v = Dvs[p_index]; // differentiation variable
        Word m = FIRST(Ms[p_index]);

        // update variable v and chaser list
        if (count >= m && v == r) { // rollover, but we're finished
            ++n_finished; // this polynomial is done.
            ++p_index; // next polynomial

            continue; // skip it
        } else if (count >= m) { // rollover - increment differentiation variable
            ++v; // next variable ...
            Dvs[p_index] = v; // ... and store
            Chase[p_index] = Backup[p_index];
            ChaseIndex[p_index] = 0;

            // calculate next m
            Word M1 = RED(Ms[p_index]);
            Word d = FIRST(M1);
            SFIRST(M1, d * m);
            Ms[p_index] = M1;

            // degree zero - no derivatives taken for this variable. next iteration will increment the variable.
            if (d == 0) continue;
        }

        // next polynomial
        Word F1 = Append[p_index];

        // compute s_k = partial_{(h_1,...,h_{k-1}),(i_1,...,i_{k-1}),v} h_k
        // get h_k and its degree
        Word P;
        ADV(Chase[p_index], &P, &Chase[p_index]);

        // construct jacobi matrix using h1 = P and i1 = v
        Word Jacobi = JacobiFromMinor(r, P, v, Hs, Is, Minor);

        // compute partial differential, determinant of jacobi matrix
        // note that Q may be a constant, we need to preserve it
        Word Q = MAIPDE(r, Jacobi); // next derivative is the jacobi determinant
        Word Qdeg = DEG(r,Q);
        bool q_const = IPCONST(r, Q);
        Word Q1 = LIST2(Q, Qdeg);
        Word Qs1 = Qs;
        if (!q_const) Qs1 = COMP(Q, Qs1); // because c /= 0 is trivially true

        // candidate stratum Y1 on which Q /= 0
        //   - 0 /= 0 is trivially false, so we immediately conclude that it's empty
        //   - const /= 0 is trivially true, so assuming the algebraic set Gs3 is non-empty, Y1 is trivially non-empty
        //   - if Q is constant, Y1 must be the last candidate, since the next one includes a trivially false equation
        if (Q != 0 && (q_const || !ISEMPTY(r, V, Gs3, Qs1, Ineqs))) {
            // Gs2 contains derivatives computed during recursion
            int strata_appended;
            Gs2 = strat_helper(r, V, Ineqs, k + 1, g_count, Gs, COMP(v, Is), COMP(P, Hs), Qs1, Jacobi, &strata_appended, S_);
            Gs1 = CONC(Gs1, Gs2);

            // determine if all derivatives at step k+1 vanish on the set Y1
            strat_count += strata_appended;

            // append stratum if none were appended during induction
            if (strata_appended == 0) {
                Word Y, k1;
                construct_stratum_basic(k, r, V, COMP(P, Hs1), Q, Qs, Gs3, Ineqs, &k1, &Y);
                append_stratum(S_, k1, Y);
                ++strat_count;
            }

            Gs3 = COMP(Q, Gs3);
            Gs = COMP(Q1, Gs);
            ++g_count;

            if (q_const) {
                // the next candidate will include the trivially false eequation const = 0. stop.
                break;
            }
        }

        // append derivative to Fs, preserving zeroes
        SRED(F1, Q1);
        Append[p_index] = RED2(F1);

        // next polynomial please.
        Chase[p_index] = RED(Chase[p_index]);
        ChaseIndex[p_index] = ChaseIndex[p_index] + 1;
        ++p_index;
    }

    Gs1 = CONC(Gs1, Gs3);
    *strat_count_ = strat_count;
    return Gs1;
}
```

- For the base case, where there are no polynomials, or index $i_k \ge r$, (Line 7), there is nothing to do. No strata are appended and no polynomials computed.
- Prior to Line 57, initialisation is done. Metadata for each polynomial in `Fs` is stored.
- The main loop, beginning on Line 57, computes partial derivatives in ascending lexicographical order of index $(i_r,\ldots,i_{k+1},j)$, $1 \le j \le q$.
- Lines 57-100 keep track of the current polynomial `P` and "differentiation variable" `v` $\in \{ x_{i_k+1},\ldots,i_r\}$.
- Line 101 calls the function `JacobiFromMinor`, which takes a $((k-1)\times (k-1))$-matrix $A = \vert a_{ij} \vert =
  \partial h_i / \partial x_j$, a polynomial $f$ and index $\ell$, and returns the $(k \times k)$-matrix obtained from
  $A$ by appending column $(\partial h_1 / \partial x_\ell, \ldots, \partial h_{k-1} / \partial x_\ell)^T$ and row
  $(\partial f / \partial x_{i_1}, \ldots, \partial f / \partial x_{i_{k-1}}, \partial f / \partial x_\ell)$. I.e., it
  constructs the matrix from the partial differential operator (Definition \@ref(def:pdo)) and saves recomputing the
  whole matrix of partial derivatives. Note that, when $k=1$, `JacobiFromMinor` returns the one-element matrix $\partial
  f / \partial x_\ell$.
- On line 105, the determinant of the matrix computed on Line 101 is calculated, for the partial differential operator.
- Line 116 determines if the candidate stratum is empty (see comment on Lines 112-115).
- If non-empty, we proceed by induction, calling `strat_helper` recursively (for $k+1$, appending index `v` and polynomial `P`, and passing the $(k \times k$-matrix as the `Minor`). The number of strata of codimension $> k$ which were added to `S` is returned. If no strata were appended, all the partial derivatives vanish identically on the candidate, and we can conclude that it is smooth and has codimension $k$.
- Line 128 represents the candidate stratum as a basic semialgebraic set containing $k$ equations. The function `construct_stratum_basic` is discussed shortly.
- The rest of the function is responsible for updating the metadata and keeping track of the list of polynomials `Gs1` to be returned.

The function `construct_stratum_basic` is responsible for representing a candidate stratum as a basic semialgebraic set defined using the $k$ polynomial equations $h_1,\ldots,h_k$. It discards redundant polynomials as described in Section \@ref(sec:strat-algorithm-details) and works only in this particular case, when the $h_1,\ldots,h_k$ form an algebraic set of codimension $k$. This follows from @gv1995, Theorem 1.

**Input:**

- `Word r` $\in \N$: ambient dimension,
- `Word k` $0 \le k \le r$: codimension of candidate stratum,
- `Word V`: variable list,
- `Word Hs` $= (h_{i_1},\ldots,h_{i_{k-1}}) \subset \Z[x_1,\ldots,x_r]$,
- `Word Q` $\in \Z[x_1,\ldots,x_r]$,
- `Word Qs` $\subset \Z[x_1,\ldots,x_r]$,
- `Word Gs` $\subset \Z[x_1,\ldots,x_r]$,
- `Word Ineqs`: a *prenex* (`QEPCAD-B`) formula of inequalities,

The parameters `Hs`, `Qs`, `Q`, `Gs` and `Ineqs` define a candidate stratum $Y_k$. All of `Hs` and `Gs` are equal to zero on $Y$, all of `Q` and `Qs` are not equal to zero on $Y$ and the formula `Ineqs` defines a semialgebraic set containing $Y$.
\newpage

**Output**

- `Word k1` $\ge$ `k` is the actual codimension of $Y$,
- `Word F` is the stratum $Y$ defined by `k1` equations and the inequations and inequalities from `Qs`, `Q` and `Ineqs`

``` {c, code-strat-basic, eval=FALSE, attr.source='.numberLines' }
void construct_stratum_basic(Word k, Word r, Word V, Word Hs, Word Q, Word Qs, Word Gs, Word Ineqs, Word *k1_, Word *Y_)
{
    Word L, P, i;
    Word Eqs = NIL, Ineqats = NIL;

    // we may have Q = const, if so don't include it.
    if (!IPCONST(r, Q)) {
        Qs = COMP(Q, Qs);
    }

    // add Qs and Hs to the definition of stratum
    L = Hs, i = k;
    while (L != NIL) {
        // equation h = 0
        ADV(L, &P, &L);
        Eqs = COMP(P, Eqs);

       --i;
    }

    L = Qs;
    while (L != NIL) {
        // inequation s /= 0
        ADV(L, &P, &L);
        Ineqats = COMP(P, Ineqats);
    }

    // we start with functions (h_1,...,h_{k-1}) and then determine which ones from Gs are required.
    Word k1 = k; // store the codimension.

    // attempt to add more polynomials from the list Gs of candidate functions.
    while (Gs != NIL) {
        ADV(Gs, &P, &Gs);

        if (!ISEMPTY(r, V, Hs, COMP(P, Qs), Ineqs)) {
            // if this set is non-empty, then there is a point at which P /= 0, thus P = 0 is necessary
            Hs = COMP(P, Hs);
            Eqs = COMP(P, Eqs);

            ++k1; // addition of a new polynomial increases the codimension
        }
    }

    // assign to return
    *k1_ = k1;
    *Y_ = LIST2(Eqs, Ineqats);
}
```

The idea is to use emptiness checking to find the minimal number, `k1` of equations needed to define the stratum $Y$ as a basic semialgebraic set. `k1` is the codimension of $Y$.

The function `ISEMPTY` performs emptiness checking.

**Input:**

- `Word r` $\in \N$,
- `Word V`: variable list $(x_1,\ldots,x_r)$,
- `Word Fs` $= (f_1,\ldots,f_q) \subset \Z[x_1,\ldots,x_r]$,
- `Word Gs` $= (h_1,\ldots,h_t) \subset \Z[x_1,\ldots,x_r]$,
- `Word Ineqs`: list of atomic `QEPCAD-B` formulas $\{ g_1 > 0 \},\ldots,\{ g_r > 0 \}$

These parameters define the input set $S \subset \R^r$ as a quantifier-free Boolean Formula
$$
F = \{ f_1 = 0,\ldots,f_q = 0, h_1 \ne 0,\ldots,h_t \ne 0, g_1 > 0,\ldots,g_r > 0 \}.
$$

**Output:**

- `true` if $S$ is empty, `false` otherwise.

``` {c, code-strat-isempty, eval=FALSE, attr.source='.numberLines' }
Word ISEMPTY(Word r, Word V, Word Fs, Word Gs, Word Ineqs)
{
    Word P, Ct, Cf;

    // start with the list of inequalities
    Word F = Ineqs;

    // add equations
    while (Fs != NIL) {
        ADV(Fs, &P, &Fs);

        F = COMP(LIST4(EQOP, P, r, NIL), F);
    }

    // and inequations
    while (Gs != NIL) {
        ADV(Gs, &P, &Gs);

        F = COMP(LIST4(NEOP, P, r, NIL), F);
    }

    // complete formula by adding the inequation and conujnction
    F = COMP(ANDOP, F);

    // re-initialise QEPCAD before each run
    QepcadCls Q;
	INITSYS();

    // set input formula
    Q.SETINPUTFORMULA(V,LIST4(r, r, NIL, F));
    Q.PRDQFF();
    Q.CADautoConst();

    // special case: trivially false
    if (Q.GVPC == 0) {
        return true;
    }

    LISTOFCWTV(Q.GVPC, &Ct, &Cf);

    /* compute CAD */
    return Ct == NIL;
}

```

The function constructs $F$, the defining formula for $S$ and uses `QEPCAD-B` to build a truth-invariant CAD of $\R^r$ compatible with $S$.
`QEPCAD-B` evaluates the input formula at the sample point of each cell to determine its truth value.
This function checks whether there are any true cells since, if $S$ is empty, all cells in the CAD constructed by
`QEPCAD-B` will be false.

## Complexity {#sec:strat-complexity}

We first briefly summarise the semi-Pfaffian case, as presented by @gv1995.
The algorithm from @gv1995, Theorem 2 takes as input a semi-Pfaffian set with the format $(r, N, \alpha, \beta, n)$ (see Definition \@ref(def:pfaff-format)) and has a complexity upper bound of
$$
3^N N^{n+1} {\cal B}
$$
where
$$
{\cal B} = (\alpha + \beta + 1)^{(r+1)^{\O(n)}}.
$$
Without the oracle, the total number of strata, some of which may be empty, does not exceed $N^{n+r}{\cal B}$, each of which has format $(r, N{\cal B},\alpha, {\cal B}, n)$.
If the oracle, used for checking emptiness, is allowed, then the algorithm has complexity not exceeding $N^{n+r}{\cal B}$.

Now consider this algorithm applied to the semialgebraic set
\begin{equation}
X := \{ \mathbf{x} \in \R^n \mid f_1 = 0, \ldots, f_q = 0, g_1 > 0, \ldots, g_r > 0 \},
(\#eq:strat-input-set)
\end{equation}
where all $s := q + r$ functions $f_i,g_j$ are polynomials with maximum degree $d$ -- Pfaffian functions of order $0$ and degree $(\alpha, \beta)$.
The upper complexity bound for the algorithm without oracle is
$$
3^{s} s^{n+1} (d + 1)^2.
$$
The number of strata, some of which may be empty, does not exceed
$$s^{n} (d + 1)^2.$$
Each stratum is defined by at most $s (d + 1)^2$ polynomial equations and inequalities of maximum degree $(d + 1)^2$.
If the oracle is allowed, no empty strata will be produced and the algorithm has complexity not exceeding
$$
s^{n+1} (d + 1)^2.
$$
These bounds follow immediately from @gv1995, Theorem 6.2.
We will now analyse the complexity of the algorithm presented in Section \@ref(sec:strat-alg-description), which performs emptiness checking on candidate strata.

There are $s^{n} (d + 1)^2$ candidate strata $Y_k$, and the algorithm determines whether each of them is empty, in order to decide whether all partial differential equations vanish identically on the input set $X$.
In the implementation, the check is done using CAD (a call to `QEPCAD-B`).
For the purposes of complexity analysis, we will use a theoretical algorithm, having singly exponential complexity in the number of variables.
@bpr98 propose an algorithm which takes a semialgebraic set $S \subset \R^n$ defined by $s$ polynomials with maximum degree $d$ in $n < s$ variables and produces a "witness" -- a point contained in every cell in a decomposition of $S$.
The algorithm can be used to determine the emptiness of $S$ and requires $s(s/n)^n d^{\O(n)}$ arithmetic operations.
This is asymptotically the same as $$(sd)^{\O(n)}.$$
Using the bounds for the number and degrees of polynomials defining strata, each emptiness check costs
$$
\left(s(d+1)^{2}(d+1)^{2}\right)^{\O(n)}=\left(s(d+1)^{4}\right)^{\O(n)},
$$
which is asymptotically the same as
$$
\left(s(d+1)\right)^{\O(n)}.
$$
This operation must be performed for all of the
$s^{n} (d + 1)^{2}$
candidate strata, resulting in a total complexity for emptiness checking of
$$
\left(s(d+1)\right)^{\O(n)^{2}}.
$$
The total complexity of stratification, given by the sum of the complexity of applying the algorithm and performing the emptiness checks, is
$$
3^{s}s^{n+1}(d+1)^{2}+\left(s(d+1)\right)^{\O(n)^{2}}.
$$
Since $s^{n+1}(d+1)^{2}$ is bounded from above by $\left(s(d+1)\right)^{\O(n)^{2}}$, we get a total complexity upper bound of
$$
3^{s}\left(s(d+1)\right)^{\O(n)^{2}}.
$$

## Test cases

Some test cases are now presented.

1.

  - **Input:** $(x,y), \{ xy = 0 \}$.

  - **Output:**

    ```
    X_(1,1):
      { y == 0
      , x /= 0
      }
    X_(1,2):
      { x y == 0
      , y /= 0
      }

    Strata of codimension 2
    X_(2,1):
      { y == 0
      , x == 0
      }
    ```

1.

  - **Input:** $(x,y), \{ x^5 y^4 = 0 \}$.

  - **Output:**

    ```
    Strata of codimension 1
    X_(1,1):
      { 120 y^4 == 0
      , 24 x^5 /= 0
      }
    X_(1,2):
      { x^5 y^4 == 0
      , 120 y^4 /= 0
      }

    Strata of codimension 2
    X_(2,1):
      { 120 y^4 == 0
      , 24 x^5 == 0
      }
    ```

1.

  - **Input:** $(x,y), x^2 + y^2 = 1$.

  - **Output:**

    ```
    Strata of codimension 1
    X_(1,1):
      { y^2 + x^2 - 1 == 0
      , 2 x /= 0
      }

    Strata of codimension 2
    X_(2,1):
      { y^2 + x^2 - 1 == 0
      , 2 x == 0
      , 4 y /= 0
      }

    ```

1.

  - **Input:** $(x,y)i, (x^2 + y^2 - 1)(x^2 - y^2) = 0$ *(unit circle plus a cross)*.

  - **Output:**

    ```
    Strata of codimension 1
    X_(1,1):
      { y^4 + 2 x^2 y^2 - y^2 + x^4 - x^2 == 0
      , 4 x y^2 + 4 x^3 - 2 x /= 0
      }

    Strata of codimension 2
    X_(2,1):
      { 16 y^5 + 32 x^2 y^3 - 16 y^3 + 16 x^4 y - 16 x^2 y + 4 y == 0
      , 4 x y^2 + 4 x^3 - 2 x == 0
      , 4 y^2 + 12 x^2 - 2 /= 0
      , 320 y^6 + 832 x^2 y^4 - 352 y^4 + 704 x^4 y^2 - 576 x^2 y^2 + 112 y^2 + 192 x^6 - 224 x^4 + 80 x^2 - 8 /= 0
      }
    X_(2,2):
      { y^4 + 2 x^2 y^2 - y^2 + x^4 - x^2 == 0
      , 4 x y^2 + 4 x^3 - 2 x == 0
      , 4 y^2 + 12 x^2 - 2 /= 0
      , 16 y^5 + 32 x^2 y^3 - 16 y^3 + 16 x^4 y - 16 x^2 y + 4 y /= 0
      }

    ```

1.

  - **Input:** $(x,y,z), x y z = 0$.

  - **Output:**

    ```
    Strata of codimension 1
    X_(1,1):
      { z == 0
      , x y /= 0
      }
    X_(1,2):
      { y z == 0
      , x z /= 0
      }
    X_(1,3):
      { x y z == 0
      , y z /= 0
      }

    Strata of codimension 2
    X_(2,1):
      { z == 0
      , x y == 0
      , y /= 0
      }
    X_(2,2):
      { y z == 0
      , x z == 0
      , z /= 0
      }

    Strata of codimension 3

    ```

1.

  - **Input:** $(x,y,z), x^2 + y^2 + z^2 = 0$.

  - **Output:**

    ```
    Strata of codimension 1

    Strata of codimension 2

    Strata of codimension 3
    X_(3,1):
      { z^2 + y^2 + x^2 == 0
      , 4 y == 0
      , 2 x == 0
      }

    ```

