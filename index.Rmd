---
title: "Cylindrical Algebraic Decompositions With Monotone Cells"
author: |
  | \medskip
  | Hollie Baker
  | \smallskip
  | A thesis submitted for the degree of Doctor of Philosophy
  | \smallskip
  | University of Bath
  | \smallskip
  | Department of Computer Science
date: "August 2024"
site: bookdown::bookdown_site
output: bookdown:gitbook
documentclass: book
bibliography: [references.bib]
biblio-style: apalike
link-citations: yes
github-repo: holliebaker/thesis
description: "Hollie Baker's thesis"
---

```{r,echo=FALSE,message=FALSE,warning=FALSE}
# Set so that long lines in R will be wrapped:
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80), tidy=TRUE)
```

## Copyright Notice { .unlisted .unnumbered }

Attention is drawn to the fact that copyright of this thesis/portfolio rests with the
author and copyright of any previously published materials included may rest with
third parties. A copy of this thesis/portfolio has been supplied on condition that
anyone who consults it understands that they must not copy it or use material from
it except as licenced, permitted by law or with the consent of the author or other
copyright owners, as applicable.
This work is licensed under CC BY-NC-SA 4.0. To view a copy of this license, visit https://creativecommons.org/licenses/by-nc-sa/4.0/

## Declarations { .unlisted .unnumbered }

The material presented here for examination for the award of a higher
degree by research has not been incorporated into a submission for
another degree.

### Declaration of Authorship { .unlisted .unnumbered }

I am the author of this thesis, and the work described therein was carried out by myself personally.

## Acknowledgements { .unlisted .unnumbered }

I wish to thank my supervisor, Prof Nicolai Vorobjov, for all his help, guidance and advice throughout my studies and for encouraging me to pursue a PhD.
I would also like to thank Prof James H. Davenport for his help and for being my lead examiner at my PhD Confirmation where he provided excellent guidance and feedback.
Thanks also to Dr Thomas Powell, my second Confirmation examiner, for his great advice and feedback, and for providing a perspective from a different area of theoretical computer science.
Thanks to all members of the Mathematical Foundations of Computer Science group, both staff and students, for listening to my talks and generally supporting me throughout my PhD.
In addition, I would like to thank Dr Matthew England, Tereso del Rio Almajano and the "Pushing Back the Doubly Exponential Wall" research group at the Universities of Bath and Coventry for insightful informal discussions in relation to the novel algorithm for computing a CAD with frontier condition.
This PhD research was funded by an EPSRC DTP grant, without which I would not have been able to complete my studies.
Finally, I would like to thank my viva examiners, Dr Gregory Sankaran and Dr Matthew England.

```{=latex}
\newpage
```

## Abstract { .unlisted .unnumbered }

A fundamental algorithm in real algebraic geometry is the Cylindrical Algebraic Decomposition (CAD).
This algorithm partitions a semialgebraic set into cells which are arranged in a particular way. However, these cells
can sometimes exhibit undesirable properties when blow-up points are present. This can make it more difficult to reason
about the input set -- e.g., to deduce its topological properties. The main result of this thesis is an algorithm,
building on the work of @bgv15 and utilising some of the tools employed by @lazard10, which constructs a CAD compatible
with a family of semialgebraic sets, each having dimension at most two, and such that each cylindrical cell is
topologically regular and the closure of each cell is a union of cells in the decomposition. Both pseudo-code and an
implementation on top of the well-known program `QEPCAD-B`, are presented. This algorithm has complexity only slightly worse than the "classical" CAD algorithm.
In addition, a novel algorithm for computing a CAD, compatible with a semialgebraic set of arbitrary dimension and such that the closure of each cell is the union of some cells in the decomposition, is presented. This algorithm has complexity triply exponential in the number of variables -- significantly worse than that of classical CAD.
For both algorithms, blow-up points may be present and no rotation of coordinates is required.
A description, including pseudo-code, and implementation of an algorithm, presented by @gv1995, for computing a smooth stratification -- a partition into nonsingular manifolds -- of a semialgebraic set, is also given.

```{=latex}
\tableofcontents
```

# Introduction {#intro}

\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\A}{\overline{\mathbb{Q}}}

\renewcommand{\O}{\mathcal{O}}
\newcommand{\sign}{\operatorname{sign}}
\newcommand{\proj}{\operatorname{proj}}
\newcommand{\lcm}{\operatorname{lcm}}
\newcommand{\lc}{\operatorname{lc}}
\newcommand{\lm}{\operatorname{lm}}
\newcommand{\ldt}{\operatorname{lt}}
\newcommand{\multideg}{\operatorname{multideg}}
\newcommand{\red}{\operatorname{red}}
\newcommand{\prim}{\operatorname{prim}}
\newcommand{\psrc}{\operatorname{psrc}}
\newcommand{\res}{\operatorname{Res}}
\newcommand{\lex}{<_{\rm{lex}}}
\newcommand{\lexeq}{\le_{\rm{lex}}}
\newcommand{\projop}[1]{{\proj_{\R^{#1}}}}
\newcommand{\projopinv}[1]{{\proj^{-1}_{\R^{#1}}}}
\newcommand{\projops}[1]{{\proj_{\opspan{#1}}}}
\newcommand{\projopsinv}[1]{{\proj^{-1}_{\opspan{#1}}}}
\newcommand{\opspan}[1]{{\operatorname{span} \{#1\}}}
\newcommand{\fr}[1]{{\operatorname{fr} \left( #1 \right)}}
\newcommand{\cl}[1]{{\operatorname{cl} \left( #1 \right)}}

\newcommand{\frt}{{\rm{fr}}}
\newcommand{\cls}{{\rm{cl}}}


## Algebraic geometry

Algebraic geometry is a fundamental and active area of research in mathematics and, loosely speaking, is concerned with
studying sets which can be defined by polynomials. A fundamental object in algebraic geometry is the algebraic variety,
a set defined by the simultaneous solutions to a system of polynomial equations. Sometimes, a wider class of sets,
semialgebraic sets, which are defined by a Boolean combination of polynomial equations and inequalities, are studied. Complex algebraic geometry involves working over an algebraically closed field, where the fundamental theorem of algebra holds, while in real algebraic geometry we are restricted to the real numbers. The focus of this research is on algorithms for computing with semialgebraic sets defined over the real numbers.

Computational algebraic geometry spans both mathematics and computer science and involves developing algorithms for working with the fundamental objects of algebraic geometry, e.g., algebraic varieties, polynomial ideals and semialgebraic sets.
Some fundamental results in this area were presented at the International Symposium on Symbolic and Algebraic Manipulation which was held in Marseille in 1979 (now part of ISSAC).
@buchberger1979 presented his criterion and an algorithm for computing a Groebner basis for a polynomial ideal defined over an algebraically closed field, which is still one of the most efficient methods for finding the complex solutions of a system of multivariate polynomial equations.
@lazard1979 also presented an algorithm, based on Macalay's multivariate resultants, for solving systems of homogeneous polynomial equations over any field (algebraically closed or otherwise), which has complexity singly exponential in the number of unknowns.
@arnon1979 described an extension to Collins' algorithm for computing cylindrical decompositions of real space, which allows one to determine the dimension of a semialgebraic set and deduce some of its topological properties.

Since then, there have been many advances in these areas, both in extending the applications of these algorithms and making them more efficient.

## Cylindrical algebraic decomposition

A fundamental result in real algebraic geometry is Tarski's Theorem [@tarski1951], which states that semialgebraic sets are closed under projection.
Tarski's paper can be obtained online here: \url{https://doi.org/10.1007/978-3-7091-9459-1\_3} and @vdd1988tarski discuss Tarski's Theorem further. 
This result is not true for algebraic sets, neither real nor complex. Indeed, consider the projection of the solutions of the polynomial $xy = 1$ onto the $x$-axis. We get $\R \setminus \{ 0 \}$, which is not an algebraic set, but could be represented if we are allowed to use inequalities. Thus, we will be working over the category of semialgebraic sets: sets of points defined by Boolean combinations of polynomial equations and inequalities.
Alfred Tarski first alluded, without proof, to his famous theorem in the abstract of @sierpinski1930. He then proved the
theorem in [@tarski1951] whose planned publication in 1939 was delayed due to the war. @seidenberg1954 published "A New
Decision Method for Elementary Algebra", which applies Tarski's theorem to quantifier elimination problems over real
closed fields, leading to the well-known Tarski--Seidenberg Theorem.
@lojasiewicz1964 gives a constructive proof of the Tarski--Seidenberg theorem using successive projections onto $(n-1)$-dimensional space. This is the idea behind the cylindrical algebraic decomposition (CAD) algorithm.

The notion and algorithm for computing a CAD was presented by @collins1975.
The algorithm partitions $\R^n$ into cylindrical cells -- semialgebraic sets such that the projection of any two of them is either disjoint or coincides.
Collins' algorithm [@collins1975] is the first computationally tractable proof of the Tarski--Seidenberg theorem, the algorithm having complexity doubly exponential in the number of variables.

CAD has wide ranging applications in real algebraic geometry.
Perhaps the most famous application is the one Collins was thinking of -- quantifier elimination: given a Boolean formula where literals are polynomial equations and inequalities where some variables are bound by $\forall$ and $\exists$ quantifiers, return a Boolean formula without quantifiers representing the same set.
A similar problem uses CAD to decide whether a formula in which all variables are quantified is true or false -- the decision problem.
More recently, alternative methods for performing quantifier elimination have been proposed, e.g., the critical point method (see @safeldin2013).
Other notable uses include determining whether a semialgebraic set is empty, computing the real roots of a system of multivariate polynomials and determining the dimension of a semialgebraic set. @bpr98 applies the critical point method to the emptiness problem, obtaining a bound singly exponential in the number of variables.
CAD can also be used to deduce topological properties of semialgebraic sets, for example by computing homology groups.

Cylindrical algebraic decompositions and algorithms forcomputing them are still active and interesting areas of study. Due to the wide range of applications, there are several directions of research. A few of these are now discussed.

### Pushing back the doubly exponential wall

Since the complexity of computing a CAD is doubly exponential in the number of variables, the algorithm can be intractable for even moderately-sized problems. It is impossible to lower this theoretical bound. Indeed, @davenportHeintz1988 prove that quantifier elimination by CAD is doubly exponential in the number of variables.
They present an example of a first-order Boolean formula with quantifiers which requires a linear number of symbols while the formula obtained after quantifier elimination requires a doubly exponential number of symbols.
@brown07 later presented a simple and constructive proof of the same thing, giving an example of a formula with only one free variable and containing only linear polynomials whose quantifier-free counterpart is doubly exponential in length.

CAD depends on a fixed coordinate ordering and this can greatly influence the number of cells produced. In the same paper, @brown07 show that the same input may produce a linear number of cells for one ordering, but a doubly exponential number of cells for another. They also present an example for which every coordinate ordering yields a doubly exponential number of cells [@brown07].
In some applications, we may be able to change the coordinate ordering. E.g., when performing quantifier elimination, we have the freedom to rearrange the variables within quantifier blocks. As such, one way to "speed up" CAD construction would be to find a coordinate ordering which yields the smallest number of cells. @hong1993 was one of the first to do this, using best first search, a heuristic search technique in AI, to find an optimal ordering. More recent developments include @delrio2022, who used complexity analysis to improve upon the current state-of-the-art heuristics, obtaining benchmark results 17 times slower than the theoretical best, while the state-of-the-art at the time performed 25 times slower than the theoretical best.
In addition, modern artificial intelligence and machine learning techniques are being investigated as a means of finding the best coordinate ordering. For example, @huang2014 employed support vector machines and @chen2020 used artificial neural networks to identify an optimal ordering.
Both of these techniques outperformed classical heuristics, making this a promising application of AI and ML.

However, in many cases we cannot change the coordinate ordering and, even if we could, @brown07 showed that for some inputs all coordinate orderings yield a doubly exponential number of cells. As such, making optimisations in the CAD algorithm itself has been an active area of study since Collins published his original algorithm in the 70s. 

Collins' algorithm works on the principal of projection and lifting. First, successive projections of input polynomials are performed, until we obtain a set of polynomials in one variable. The roots of these polynomials are isolated and then "stacks" of cells above each root and each interval in between the roots are constructed. The CAD of $n$-dimensional space is obtained by iterating this process, called the "lifting phase".
Minimising the number of polynomials produced by the projection operation means fewer computations are needed during the lifting phase. @mccallum1998 proposed an improved projection operator, observing that some polynomials included in Collins' original projection operator can be removed. Many other projection operators, e.g., Hong's (see @hong1990) and Lazard's (see @mccallum2019) projection operators have been proposed, each offering different properties. Another optimisation is to construct a "partial CAD", proposed by @collins1991. The idea is to use truth evaluation while constructing cells, taking quantifiers into account, so that only the cells we care about will be computed. As we do not have to ensure constant sign on every polynomial, this approach leads to savings during the lifting phase and often a reduced number of cells. The CAD algorithm has also been modified, often by weakening its properties, to solve specific problems. E.g., @mccallum1993 presents an algorithm, based on CAD, for deciding the consistency of a system of strict polynomial inequalities. These modifications often have much better complexity than the classical CAD, while producing sufficient decompositions to solve the problem at hand.

### Satisfiability modulo nonlinear arithmetic

Given a Boolean formula where atoms are Boolean variables as input, the satisfiability (SAT) problem asks whether there is an assignment of values true and false to the variables appearing in the input formula which makes the formula true. An extension of the SAT problem is the satisfiability modulo theories (SMT) problem. In this case, atoms are some class of expression which can be evaluated to yield true or false. CAD is well-suited to solving SMT problems where input formulas are Boolean combinations of polynomial equations and inequalities. Indeed, a witness, which is a point at which the input formula is true, can be taken as the sample point of a true cell in the CAD. If no true cells exist, we can conclude that the formula is unsatisfiable. 
However, a CAD contains far more information than necessary to decide whether the input formula is satisfiable.
A recent strand of research aims to use ideas from CAD to efficiently solve this problem. 

One approach is to try to guess the sample point and use parts of the CAD algorithm to refine the guess until either a valid witness is found or it can be concluded that none exists. 
A well-known example of this was the NLSAT algorithm developed by @jovanovic2012, which uses a conflict-driven clause learning approach informed by CAD projection. The high complexity of CAD arises from the number of projection polynomials produced and the NLSAT algorithm represented a moderate reduction in the number of these polynomials.
@brown2015 made significant progress in reducing the number of polynomials by developing an algorithm which constructs a single CAD cell. 
However, this algorithm takes polynomials one at a time, and the order in which polynomials are chosen has a significant affect on the size and shape of the CAD cell produced. 
@nalbach2024 designed and implemented the SMT-RAT solver which further improves on NLSAT and Brown's single cell construction. 
Instead of adding polynomials one at a time, @nalbach2024 constructs a single CAD cell level by level, according to some variable ordering, using a reduced set of projection polynomials. 
This level-wise construction has the advantage that a variety of different reductions can be considered and heuristics can be used to select the optimal projection polynomial in order to make the CAD cell under construction as simple as possible. 
SMT-RAT has been validated using the SMT-LIB library and the authors report significant efficiency improvements over NLSAT. 

Since only a witness point is needed, another approach is to weaken the CAD structure. 
@abraham2021 find a sample point (witness) incrementally, refining their search by considering the input constraints and previous conflicts. 
The algorithm begins with some coordinates of a candidate sample point and then proves that this point cannot be extended to a full sample. Using the reasons for this, the algorithm eliminates larger and larger chunks of ambient space until a cylindrical algebraic covering is constructed. 
While each cell in a cylindrical algebraic covering has constant truth value on the input formula, a cylindrical algebraic covering is weaker than a cylindrical algebraic decomposition because cells are allowed to overlap.

### Constructing CADs with desirable properties { #sec:cad-des-prop }

A different strand of research, which is the main focus of this thesis, is to compute cylindrical decompositions in which the cells have certain desirable properties. This contrasts with the areas of research just discussed, which typically aim to minimise the running time and / or number of cells, because these CADs often contain more cells than those constructed using the classical algorithm. However, this trade-off is worthwhile because the additional conditions make the CADs more powerful.
Indeed, @pianomovers1983 apply cylindrical algebraic decomposition to a motion planning problem in which one wants to find a path, or prove that none exists, for a rigid (possibly hinged) body to move through a space defined by a configuration of walls. This has obvious applications in robotics. In order to solve this problem, cells are required to be arranged in a particular way: the closure of every cell must be a union of cells in the decomposition. Using classical CAD, this condition cannot always be satisfied, but @pianomovers1983 prove the classical algorithm is sufficient if a linear change of coordinates is made.
These CADs are also useful if we wish to compute topological properties of semialgebraic sets. For example, @reif1979 gives an algorithm for computing the homology groups of an arbitrary real algebraic variety. As we alluded to earlier, over the reals, a formula cannot tell us much about the set it defines, so this is useful for deducing properties of semialgebraic sets, e.g., how many "holes" it has, or whether it is connected.
Along similar lines, @arnon1984 present an algorithm to compute a CAD of the plane along with information about which
cells "touch each other". They extend this result to $3$-dimensional space in [@arnon1987].
In order to compute these cell adjacencies, we again need the property that the closure of every cell is a union of some cells in the decomposition. @arnon1987 achieve this without making a change of coordinates. More recently, @strzebonski2017 published an algorithm for computing cell adjacencies for CADs in arbitrary dimension. However, their algorithm only works if the CAD is well-based. I.e., no input polynomial vanishees identically over a CAD cell. 

Another desirable property is that every cell in a cylindrical decomposition is a topologically regular cell. Loosely speaking, this means that each $k$-dimensional cell $C$ and its closure $\cl{C}$ is homeomorphic to the pair $(B, \cl{B})$, where $B$ is the $k$-dimensional open ball and $\cl{B}$ is its closure.
This property can fail in the region of points where polynomials are not "well behaved".
E.g., blow-up points: points where a polynomial vanishes over an open interval (for the precise definition, see Definition
\@ref(def:blow-up-point)).
For example, consider the Whitney umbrella, the set of points in $\R^3$ which satisfy the equation $f = 0$ where
$$
f := x^2 - y^2 z.
$$
At almost every point $(x,y) \in \R^2$, $f$ is well-behaved -- having only one value of $z$ at which it is equal to zero.
However, $f$ "blows up" above the origin, vanishing at every point. This causes interesting behaviour as $(x,y)$ approaches the origin, because the $z$-coordinate tends to infinity. Thus, the set
\begin{equation}
\{ 0 < x < 1, -1 < y < 1, x^2 - y^2 z = 0 \},
(\#eq:basic-semialgebraic-whit)
\end{equation}
which is a cylindrical cell in $\R^3$, is not topologically regular and its closure contains the half-line $\{ x = 0, y = 0, z \ge 0 \}$.
We will study CADs containing blow-up points and cells which are not topologically regular throughout this thesis.
@lazard10 presents an algorithm which produces such a decomposition, in the potential presence of these blow-up points, for dimension $\le 3$, without requiring a rotation of coordinates. This so-called "strong" cylindrical algebraic decomposition consists of only topologically regular cells and the closure of every cell is a union of some cells in the decomposition. @lazard10 takes an algebraic approach, employing techniques such as computing the saturation of a polynomial ideal, to make computations efficient, and explains how the algorithm can be implemented in Maple.

Many inputs to the CAD algorithm do not contain blow-up points. @jhd20 prove that the classical CAD algorithm will produce a strong decomposition for the given coordinate ordering and regardless of the method used to compute it as long as no blow-up points are present. This is a very useful result as it allows us to take advantage of the nice properties of strong decompositions without doing any extra work to obtain them.
However, sometimes blow-up points are unavoidable. For example, @bgv15 propose an algorithm for computing a triangulation of a definable monotone family which relies on a strong cylindrical decomposition of that family. Since these families depend on a fixed coordinate ordering and frequently contain blow-up points, we need to be able to compute these strong decompositions in arbitrary dimension, in the potential presence of blow-ups and without having to make a change of coordinates.

Note that, in Equation \@ref(eq:basic-semialgebraic-whit), we write a basic semialgebraic set of the form
$$
\{ \mathbf{x} \in \R^n \mid f_1(\mathbf{x}) = 0 \land \ldots \land f_k(\mathbf{x}) = 0 \land g_1(\mathbf{x}) > 0 \land \ldots \land g_\ell(\mathbf{x}) > 0 \}
$$
as
$$
\{ f_1(\mathbf{x}) = 0, \ldots, f_k(\mathbf{x}) = 0, g_1(\mathbf{x}) > 0, \ldots, g_\ell(\mathbf{x}) > 0 \}.
$$
I.e., commas represent conjunction. When not ambiguous, this convention will be used throughout.

## Research aims and background

@bgv15 present a constructive proof that, given a family $V := (V_1,\ldots,V_k)$ of bounded definable sets in $\R^n$
such that $\dim(V_i) \le 2$ for all $1 \le i \le k$, there exists a cylindrical decomposition in which each $V_i, 1 \le
i \le k$ is a union of cells, such that every cell contained in $V_i$ is monotone and its closure is the union of cells
in the decomposition. A monotone cell is a stronger property than topological regularity and, by @bgv13 Theorem 1, all
monotone cells are topologically regular. Their proof explains how such a decomposition can be constructed and depends
on classical CAD and simple tools such as refinements by linear equations and splitting $2$-dimensional cells by intersecting it with a given curve interval.
The main goal of this thesis will be to design and implement an algorithm, based on this result, for constructing such a decomposition in the semialgebraic case.
The constructive proof works for more general definable sets and, in contrast to e.g. @collins1975 or @lazard10, is
geometric in nature. As such, the properties we need to satisfy in order to complete the construction are described in
detail. However, methods to obtain these properties are not given. The bulk of this thesis is concerned with transforming this constructive proof into an algorithm, presented as pseudo-code, and then implementing it. We wil also perform complexity analysis. (TODO and benchmarking?) 
We will use a combination of fundamental tools in differential geometry, e.g., partial derivatives and Jacobi determinants, well-known algorithms in algebraic geometry such as smooth stratification and quantifier elimination, and ideas from optimisation, such as Lagrange multipliers.

A similar idea to that presented by @bgv15 is discussed by @vdd1998 (Section 2.19), who introduces the concept of a Van-den-Dries regular cell.
We say that a cylindrical cell $C \subset \R^n$ is Van-den-Dries regular if, for all $i \in \{1,\ldots,n\}$, if two distinct points $\mathbf{x},\mathbf{y} \in C$ are such that $x_1 = y_1, \ldots, x_{i-1} = y_{i-1}, x_{i+1}, \ldots, x_n = y_n$, but $x_i < y_i$, then for all $z_i$ such that $x_i < z_i < y_i$, $(x_1,\ldots,x_{n-1},z_i,x_{i+1},\ldots,x_n) \in C$.
All $2$-dimensional Van-den-Dries regular cells are topologically regular, so if $\dim(V_1\cup\ldots\cup V_k) \le 2$, the
decomposition described by @vdd1998 will consist of topologically regular cells. The result of @bgv15 is stronger in that the monotone decomposition is obtained for a family of sets which individually have dimension at most two.

Part of the result from @bgv15 will be generalised to sets of arbitrary dimension. In particular, given a semialgebraic set, we wil present a novel algorithm for constructing a cylindrical decomposition such that the input set consists of a union of cells of that decomposition and the closure of every cell is the union of some cells in the decomposition. We call the latter property, that the closure of cells is a union of cells in the same decomposition the "frontier condition". 
(This work was presented, in extended abstract form, at CASC 2023 and has been submitted for journal publication.)
We prove that such a decomposition can be constructed in any dimension and without a preliminary change of coordinates even in the presence of blow-ups. To our knowledge, this is the first proof that such a CAD exists without the change of coordinates.
The proof takes the form of an algorithm, given as pseudo-code and a mathematical description, which constructs a CAD compatible with a semialgebraic set $S \subset \R^n$ and satisfying the frontier condition.
We also obtain an upper bound on the complexity of this algorithm. This is also an upper bound on the number of cells, number of polynomials and
degree of polynomials in the CAD. The algorithm has elementary complexity (in the sense of L. Kalmar, see e.g.,
[@kleene1952, $\S 57$]). This means that the complexity can be expressed as a power tower of finite height.

As discussed in Section \@ref(sec:cad-des-prop), the frontier condition is useful in many applications including motion planning, computing homology groups and determining cell adjacencies. 
In addition, we show how this result can be applied to other categories, e.g., semialgebraic sets defined by *fewnomials* (see Section \@ref(sec:pfaffian)), whose structure is destroyed by a change of coordinates.
The result can also be easily extended to semialgebraic sets defined by first-order Boolean formulas with quantifiers.
Indeed, by Theorem \@ref(thm:proj), the projection of a CAD with frontier condition to any dimension also satisfies the frontier condition, and quantifier elimination requires considering projections of the CAD.

This result partially extends the work of @arnon1984, @arnon1987 and @lazard10, from ambient dimension at most three to arbitrary dimension.
Our construction uses a recursion on the lexicographical order of cell indices. A novel approach was needed because it is not clear how the above results could be extended to dimension greater than $3$.

Finally, we will describe an algorithm for computing a smooth stratification of a semialgebraic set. A smooth stratification is a finite partition of a set into smooth manifolds called "strata". We present an algorithm, based on the work of @gv1995 for computing a smooth stratification of a semialgebraic set such that each stratum is nicely defined, meaning that each stratum of codimension $k$ is defined by $k$ different polynomials.
The algorithm is designed to handle input sets which are not nicely defined. E.g., sets defined by polynomials whose first partial derivatives vanish at every point in the set.
For example, the algebraic set
$$
S := \{ x y = 0 \}
$$
has codimension $1$, and thus can be defined by a single polynomial. However, it is not smooth, since $S' = (0,0)$ is a singular point of $S$. $S'$ has codimension $2$ and it is clear that it can be written using two polynomials
$$
S' = \{ x = 0, y = 0 \}.
$$
Observe that $x$ and $y$ are the first derivatives of the defining function $xy$. However,
$$
\{ x^m y^n = 0, m \ge 1, n \ge 1 \}
$$
defines the set $S$ and, if $m > 1$,
$$
\dfrac{\partial x^m y^n}{\partial x} = m x^{m-1} y^n
$$
is equal to zero at the same points as $x^my^n$. Thus, it may not be sufficient to find the points at which only the first derivatives vanish. This is the basic idea of the smooth stratification algorithm we will present.
The algorithm also ensures that only the $k$ functions required to define a stratum of codimension $k$ are included, "pruning" functions which do not add any additional information.

## Contributions of this thesis

Chapter \@ref(sec:background) gives some necessary definitions, then presents some useful results from @bgv15. The CAD
is then formally defined, and the flow of the algorithm, following the description given by @coste2000, is outlined.

We now detail the contributions made in each chapter and how the work is differentiated from @gv1995 and @bgv15, on which much of the research is based. 

### Smooth stratification algorithm

Chapter \@ref(sec:smooth-strat) presents the smooth stratification algorithm from @gv1995, Theorem 2.
The proof of @gv1995, Theorem 2 describes a procedure for constructing a smooth stratification of a semi-Pfaffian set. 
We formulate this construction as pseudo-code and specialise it to the case of semialgebraic sets where it is possible to implement the subroutine of checking whether a candidate stratum is empty.
This algorithm has been implemented in C on top of `SACLIB`. `SACLIB` is an open-source C/C++ library for manipulating real polynomials and real algebraic numbers and working with their solutions as real algebraic numbers (see @saclib).
Although this construction has been described at least twice (in @gv1995 and @gv04), this is the first presentation of the procedure as pseudo-code and the first implementation of the algorithm. We also contribute complexity results for the semialgebraic case. 

### Monotone and frontier condition

In Chapters \@ref(sec:quasi-affine), \@ref(sec:monotone-cells) and \@ref(sec:frontier-bgv), we present an algorithm for constructing a CAD of $\R^n$, monotone with respect to a family of semialgebraic sets $V = (V_1,\ldots,V_k)$ such that $\dim(V_i) \le 2$ for $1\le i \le k$ and satisfying the frontier condition.
I.e., each cell of the decomposition produced by this algorithm is a topologically regular cell and its closure is a union of cells in the same decomposition. 
This algorithm is based on the proof of @bgv15, Theorem 3.20. which gives a mathematical description of how such a decomposition can be constructed.
The proof is constructive in the sense that it outlines a series of steps required to pass from the family of input sets to the resulting cylindrical decomposition. However, it does not explain how each step should be completed. For example, the first step is to construct a cylindrical decomposition compatible with the smooth $2$-dimensional locus of $V$ and the critical points of projections of each $V_i$ onto $1$- and $2$-dimensional coordinate subspaces of $\R^n$, but it does not explain how the smooth locus should be computed or the critical points found. 
The main goal of Chapters \@ref(sec:quasi-affine), \@ref(sec:monotone-cells) and \@ref(sec:frontier-bgv) is to convert the constructive proof from @bgv15 into an algorithm by explaining how the required constructions can be achieved. Thee algorithm is presented as psuedo-code and obtain complexity upper bounds for the algorithm. This turns the proof that such a decomposition exists into a sequence of steps which can be implemented in a computer.
The algorithm has been implemented on top of `QEPCAD-B`. 
@bgv15, Theorem 3.20 supposes that $V$ is a family of bounded definable sets. We specialise the construction to the semialgebraic case. 

According to the proof of @bgv15, Theorem 3.20, the construction proceeds in three stages. 
Chapter \@ref(sec:quasi-affine) explains how to implement the construction described in @bgv15, Theorem 3.19.
We present an algorithm wich takes a family $V = (V_1,\ldots,V_k)$ of bounded semialgebraic sets, each of which has dimension at most two as input and constructs a CAD compatible with each $V_i, 1\le i \le k$. Each cell $C \subset V$ of this decomposition is smooth, i.e., if it has dimension $k$, then it looks locally like $\R^k$ (see Definition \@ref(def:analytic-submanifold)).
The decomposition is also constructed such that each cell contained in $V$ is the graph of a quasi-affine map. 
This is a technical notion due to @bgv15 (see Definition \@ref(def:quasi-affine)) predominantly used as an intermediate step needed to obtain topologically regular cells. It requires that, for the projection map from $\R^n$ onto each subspace defined by a subset of the coordinates $x_1,\ldots,x_n$, if the image of $C$ under the projection map has the same dimension as $C$, then the projection map must be injective. Intuitively, if $C$ fails to be quasi-affine, then $C$ "curls" or "folds" over itself.
The proof of @bgv15, Theorem 3.19 instructs us to compute a CAD, compatible with each $V_1,\ldots,V_k$, the smooth locus of $V$ and the critical points of projections onto $1$- and $2$-dimensional coordinate subspaces. 
We observe that the smooth locus can be found using the smooth stratification algorithm from Chapter \@ref(sec:smooth-strat) and then use results from @mccallum1998 to achieve smooth cells by using a certain projection operator. 
We then use the relationship between the ranks of Jacobi matrices and critical poitnsn to compute some new polynomials, based on the projection polynomials defining each $1$- and $2$-dimensional cell, which are equal to zero at the required critical points of projections. 

Next, Chapter \@ref(sec:monotone-cells) discusses, following the proofs of @bgv15, Theorem 3.20 and Theorem 3.18, how the CAD constructed in Chapter \@ref(sec:quasi-affine) can be refined such that each CAD cell contained in the input set is a topologically regular cell. Actually, the construction due to @bgv15 guarantees a stronger property which turned out to be easier to obtain -- that the refinement is monotone with respect to each $V_1,\ldots,V_k$. Informally, the cell $C$ is monotone if its intersection with every possible coordinate subspace, if non-empty, consists of exactly one connected component (see Definition \@ref(def:monotone-cell)). All monotone cells are graphs of quasi-affine maps, but not all graphs of quasi-affine maps are monotone (see Example \@ref(exm:monotone-cells) for further explanation). 
@bgv13, Theorem 1, proved that any monotone cell is also topologically regular. 
The CAD constructed in Chapter \@ref(sec:quasi-affine) has been prepared so that monotone cells can be obtained by performing some simple refinements. These refinements involve intersecting cells of the CAD with straight lines and half-planes and they only require chopping a $1$-dimensional sector cell (an open interval) in some induced decomposition into two intervals and a point. It is relatively easy to propagate this refinement to cells projecting on this refined sector because the expensive process of lifting need not be redone. Instead, cells can just be copied. Only the positional index and sample points have to be updated. 
The contribution of this chapter is a method for finding these refinement points. 
@bgv15, Theorem 3.18 instructs us to find critical points of the tops and bottoms of two-dimensional cells. We found that Lagrange multipliers, which allow us to find local maxima and minima on a surface subject to polynomial constraints, lend themselves well to solving this problem. We discuss how to apply this method, taking care to handle points where the tops and bottoms of section cells are not defined. Again, determinants of Jacobi-like matrices come in very useful. 

By the end of Chapter \@ref(sec:monotone-cells), we have a CAD which is monotone with respect to each $V_1,\ldots,V_k$. 
Chapter \@ref(sec:frontier) describes how to complete the construction required by @bgv15, Theorem 3.20, by refining this CAD so that it satisfies the frontier condition. I.e., the closure of each cell $C \subset V$ is a union of cells in the same decomposition.  
Section \@ref(sec:frontier-bgv) describes how the construction given in the last part of the proof of @bgv15, Theorem 3.20 can be applied to obtain the frontier condition. 
This algorithm requires the closure of each $2$-dimensional cell to be computed.
Assuming that we have a fast quantifier elimination algorithm, we discuss how this procedure can be implemented using the tools we have already developed in Chapter \@ref(sec:monotone-cells). 
Then, searching for a computationally cheaper method, we explore an alternative approach, based on results from @lazard10. 
In Section \@ref(sec:lazard-3), an algorithm, due to @lazard10, for constructing a CAD of ambient dimension less than or equal to 3, such that each cell is topologically regular and satisfying the frontier condition, is presented. 
Section \@ref(sec:lazard-n) explores how this method can be generalised to our situation. In order to do this, the results of
@lazard10, Section 5.3 are generalised from $\R^3$ to the $2$-dimensional cells in a CAD of $\R^n, n > 3$.

Each stage of the algorithm has been presented as psuedo-code, along with a complexity upper bound, and Chapter \@ref(sec:implementation-and-testing) discusses its implementation on top of Brown's `QEPCAD-B` [@brownQepcad] and presents some test cases.
This extends the result that such a CAD exists (@bgv15, Theorem 3.20) into a tangible implementation of an algorithm for constructing one. 

### Frontier condition in arbitrary dimension

The final contribution, in Chapter \@ref(sec:novel-frontier), is a novel algorithm for constructing a CAD of $\R^n$, compatible with a semialgebraic set of arbitrary dimension and satisfying the frontier condition. This algorithm relies on a recursion on the lexicographical order of indices $(i_1,\ldots,i_n) \in \{ 0,1 \}^n$ associated with each cell in a cylindrical decomposition and has complexity triply exponential in the number of variables.


Chapter \@ref(sec:conclusions) discusses conclusions and further work.

